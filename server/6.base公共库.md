# base公共库
---

## Common-Group1

### base64编解码

base64就是使用64个可打印的字符来表示二进制的数据，本质上是一种编码方式，用于<font color='#BAOC2F'>将二进制数据转换成可打印字符的形式</font>。它的作用是将二进制数据在不损失数据的情况下进行表示，以便在文本环境中传输或存储。

#### 应用场景

在实际开发中，Base64 编码经常用于以下情况：

1. 数据传输：当需要<font color='#BAOC2F'>在文本协议或文本格式中传输二进制数据时</font>，常常需要将二进制数据编码成 Base64 格式，以<font color='#BAOC2F'>确保数据能够正确地传输和解析</font>。例如，在电子邮件中传输二进制附件、在HTTP请求中传输图片或文件等。
2. 数据存储：有些<font color='#BAOC2F'>存储介质或存储格式只支持文本数据</font>，无法直接存储二进制数据。在这种情况下，可以将二进制数据进行 Base64 编码后再进行存储。<font color='#BAOC2F'>常见的例子是将图片数据以 Base64 编码的形式存储在数据库中</font>。
3. URL 参数传递：在 URL 中传递特殊字符或二进制数据时，为了避免特殊字符对 URL 的解析造成干扰，常常需要将二进制数据进行 Base64 编码后再传递。
4. 数据加密：有些加密算法只能处理特定长度的数据，而输入的数据长度不满足要求时，可以使用 Base64 编码将数据填充至满足要求的长度后再进行加密。

总而言之，Base64 编码在实际开发中<font color='#BAOC2F'>主要用于将二进制数据转换成文本格式</font>，以便在各种文本环境中进行传输、存储或处理。

#### base64编解码原理

base64使用64个可打印的字符来表示二进制的数据，

- [彻底弄懂base64的编码与解码原理](https://zhuanlan.zhihu.com/p/408318391) 
- [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770) 

加密与编码的区别：

1. 加密：将明文变为一种不可破解的密文，提高识别难度
2. 编码：换一种体现形式，以便于传输提高计算机可读性

base64编码表：

![image-20230611200925437](assets/image-20230611200925437.png)

以将中文使用base64编码为例：

1. step1：找到中文字符在操作系统中相应字符编码的代表码（chcp）GB2312，中文找到字符编码中的十进制值
2. step2：将十进制转为二进制
3. step3：对二进制进行分组，每六个一组（最后一组不满6位补0即可）
4. step4：将分组后的二进制组转为十进制
5. step5：在base64表中查找其对应的编码（可使用不同的编码表达到数据加密的效果）

#### 代码实现

- 学习到的编程技巧1：断言assert运用判定验证条件是否为真

断言 (assert) 是一种在程序中<font color='#BAOC2F'>用于验证条件是否为真的机制</font>。

它用于<font color='#BAOC2F'>在代码中插入检查点</font>，以<font color='#BAOC2F'>确保特定条件满足或特定状态正确</font>。如果<font color='#BAOC2F'>断言的条件为假</font>，则<font color='#BAOC2F'>断言会引发一个异常终止程序的执行</font>。

- 学习到的编程技巧2：利用二进制位运算获取最低 n 位二进制数据

- 利用位运算提取一个字节（最低的8位二进制）数据：accumulator & 0xffu
    - `0xffu` 是一个无符号整数常量，它的二进制表示为 `00000000 00000000 00000000 11111111`
    - 按位与将`accumulator`的值与`0xffu`进行按位与操作，实际上是将`accumulator`的高位部分清零，只保留最低的 8 位数据。
    - 这个操作的目的是提取`accumulator`中的最低有效字节，即保留最右边的 8 位二进制数据。
    - 通过该运算后得到的结果是一个<font color='#BAOC2F'>无符号整数</font>，表示`accumulator`中的最低有效字节。
    - 最后将提取到的 8 位二进制数据转换为 `char` 类型，然后添加到 `retval` 字符串中，用于存储解码后的原始二进制数据。
- 利用位运算提取（最低的6位二进制）数据：accumulator & 0x3fu
    - `0x3fu` 是一个无符号整数常量，它的二进制表示为 `00000000 00000000 00000000 00111111` 
    - 按位与将`accumulator`的值与`0x3fu`进行按位与操作，实际上是将`accumulator`的高位部分清零，只保留最低的 6 位数据。
    - 这个操作的目的是从 `accumulator` 中提取最低的6位二进制数据，以获取索引值。
    - 通过该运算后得到的结果是一个<font color='#BAOC2F'>无符号整数</font>，它的值在 0 ~ 63 的范围内，对应于 `b64_table` 中的有效索引。
    - 最后使用该索引从 `b64_table` 中找到相应的 Base64 字符，并将其存入 `retval` 字符串中，用于进行解码操作。

```cpp
#ifndef __BASE64_H__
#define __BASE64_H__

std::string base64_decode(const std::string &ascdata);
std::string base64_encode(const std::string &bindata);

#endif
```

```cpp
#include <stdio.h>
#include <iostream>
#include <string>
#include <cassert>
#include <limits>
#include <stdexcept>
#include <cctype>

using namespace std;

// base64编码表 用于将6位二进制值映射到相应的Base64字符
static const char b64_table[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// reverse_table解码表 用于将Base64字符映射回原始的6位二进制值
static const char reverse_table[128] = {
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64
};

/**
 * @brief base64编码过程
 * 
 * @param const string &bindata 待编码的01二进制数据
 * @return string Base64编码字符串
*/
string base64_encode(const string &bindata) {
    using std::numeric_limits;
    
    // 1.首先检查待编码的数据是否过大
    // numeric_limits<string::size_type>::max()获取 string::size_type 类型的最大值
    // 将最大值除以4 再乘以3 以确定进行Base64编码后的最大字符串长度
    if (bindata.size() > (numeric_limits<string::size_type>::max() / 4u) * 3u) {
        //throw length_error("Converting too large a string to base64.");
        /* 如果待编码的数据长度超过限制 返回空字符串 */
        return "";
    }

    // 2.根据二进制数据的长度 计算编码后的字符串长度
    const size_t binlen = bindata.size();
    // 初始化string对象来存储编码结果: 第一个参数为字符串长度 第二个参数为初始化字符串的值
    // 使用(binlen + 2) / 3可以确保编码后的字符串长度能够容纳所有的数据
    // 乘以4是因为每3个字节的数据会编码为4个字符（3 * 8 = 4 * 6）
    string retval((((binlen + 2) / 3) * 4), '=');


    // 3.函数通过迭代遍历输入数据的每个字节，并将字节转换为对应的Base64字符
    size_t outpos = 0;//retval中存储字符的位置
    int bits_collected = 0;//跟踪累加器中已经收集的比特位数
    unsigned int accumulator = 0;//用于存储累加器的值
    const string::const_iterator binend = bindata.end();//指向字符串bindata结尾位置的迭代器

    for (string::const_iterator i = bindata.begin(); i != binend; ++i) {
        //每次迭代将当前字节与0xffu按位与运算
        //将其左移8位并与accumulator进行按位或运算 以确保只取字节的低8位
        accumulator = (accumulator << 8) | (*i & 0xffu);
        //将新的字节添加到累加器中
        bits_collected += 8;
        //当累加器中的比特位数bits_collected达到6位或以上时
        while (bits_collected >= 6) {
            bits_collected -= 6;//表示已从累加器中取出了6位值
            //将accumulator右移并与0x3fu按位与运算 以获取累加器中的6位值对应的索引
            int index = (accumulator >> bits_collected) & 0x3fu;
            //根据索引从b64_table中找到相应的Base64字符，并将其存入retval中
            retval[outpos++] = b64_table[index];
        }
    }

    // 4.最后如果存在剩余的不足6位的二进制位 则将累加器左移使剩余位移动到高位 再次索引并存入retval
    // Any trailing bits that are missing.
    // 利用断言assert验证条件是否为真
    if (bits_collected > 0) {
        //剩余不足6位的二进制位 但bits_collected值大于等于6 断言失败并抛出异常（值错误或算法逻辑错误）
        assert(bits_collected < 6);
        //剩余的不足6位的二进制位 且bits_collected < 6 则进行左移操作
        accumulator <<= 6 - bits_collected;
        //并通过与0x3fu按位与运算获取索引
        int index =  accumulator & 0x3fu;
        //根据索引从b64_table中找到相应的Base64字符，并将其存入retval中
        retval[outpos++] = b64_table[index];
    }

    // 5.通过不断更新的outpos来确定retval中存储字符的位置 使用断言assert进行一些边界检查 确保编码结果的正确性
    // 确保outpos的值不小于retval的长度减去2：是否正确计算了编码结果的长度，并且没有发生越界访问
    assert(outpos >= (retval.size() - 2));
    // 确保outpos的值不大于等于retval的长度：检查是否正确更新了outpos的值，避免越界写入retval
    assert(outpos <= retval.size());

    return retval;   
}

/**
 * @brief base64解码过程
 * 对Base64编码字符串进行逐字符解码 并将解码后的二进制数据以字符串形式存储在retval中
 * 
 * @param const string &ascdata Base64编码字符串
 * @return string 01二进制数据
*/
string base64_decode(const string &ascdata) {
    string retval;
    const string::const_iterator last = ascdata.end();//ascdata字符串的末尾位置的迭代器
    int bits_collected = 0;//表示当前已收集的二进制位数
    unsigned int accumulator = 0;//用于累积收集的二进制数据的变量

    // 逐字符解码 并将解码后的二进制数据以字符串形式存储在retval中    
    for (string::const_iterator i = ascdata.begin(); i != last; ++i) {
        const int c = *i;
        // 1.当前字符是否为空格或者为等号，如果是则跳过该字符
        // 在Base64编码中空格和填充字符'='是可以存在的，但对解码结果没有影响 故直接跳过
        if (isspace(c) || c == '=') continue;

        // 2.检查当前字符是否在合法的范围内，异常返回空字符串
        if ((c > 127) || (c < 0) || (reverse_table[c] > 63)) return "";

        // 3.将收集到的二进制数据累积到accumulator中
        // 将accumulator左移6位 并与reverse_table[c]按位或运算
        accumulator = (accumulator << 6) | reverse_table[c];
        // 将bits_collected增加6，表示已经收集了6位二进制数据
        bits_collected += 6;

        // 4.如果bits_collected达到或超过8，表示已经收集足够的二进制数据可以解码为一个字节
        if (bits_collected >= 8) {
            bits_collected -= 8;
            //从accumulator中取出最高位的8位二进制数据，并将其转换为字符类型添加到retval字符串中
            retval += (char)((accumulator >> bits_collected) & 0xffu);
        }
    }
    return retval;
}
```



### AES加解密

![image-20230612130111267](assets/image-20230612130111267.png)

主要用于处理AES加解密（对称加密算法加密和解密用相同的密钥），和MD5计算

高级加密标准(AES,Advanced Encryption Standard)为<font color='#BAOC2F'>最常见的对称加密算法</font>（微信小程序加密传输就是用这个加密算法的）

该模块依赖于UtilPdu、Base64和openssl/aes，该模块主要用于<font color='#BAOC2F'>AES加解密和MD5计算</font>。

#### AES

在密码学中，加密算法分为双向加密和单向加密。

- 单向加密包括MD5、SHA等摘要算法，它们是不可逆的。
- 双向加密包括对称加密和非对称加密，双向加密是可逆的，存在密文的密钥。
    - 对称加密指，<font color='#BAOC2F'>加密和解密使用相同密钥</font>的加密算法。包括AES加密、DES加密等。AES算法是DES算法的替代者，也是现在最流行的加密算法之一。
    - 非对称加密指，<font color='#BAOC2F'>加密和解密使用不同密钥的加密算法</font>，也称为公私钥加密。常见的非对称加密算法包括：RSA、DSA（数字签名用）、ECC（移动设备用）、Diffie-Hellman、El Gamal。

AES是高级加密标准，在密码学中又称<font color='#BAOC2F'>Rijndael加密法</font>，是美国联邦政府采用的一种<font color='#BAOC2F'>区块加密标准</font>。这个标准用来替代原先的DES，目前已经被全世界广泛使用，同时AES已经成为对称密钥加密中最流行的算法之一。AES支持三种长度的密钥：128位，192位，256位。

#### AES秘钥

密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用同一个密钥。

AES支持三种长度的密钥：128位，192位，256位，AES128，AES192，AES256

#### AES填充

1. AES具有分组加密的特性，AES算法在对明文加密的时候<font color='#BAOC2F'>并不是把整个明文一股脑加密成一整段密文</font>，而是<font color='#BAOC2F'>把明文拆分成一个个独立的明文块</font>，每一个明文块长度128bit。

2. 这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。

3. 当一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit的时候就需要对明文块进行填充（Padding）。

4. AES具有三种填充模式：

    - NoPadding：不做任何填充，但是要求明文必须是16字节的整数倍。

    - PKCS5Padding：如果明文块少于16个字节128bit，在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。

        比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

    - ISO10126Padding：如果明文块少于16个字节128bit，在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。

        比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}

![image-20230612162503751](assets/image-20230612162503751.png)

#### AES算法流程

AES加密算法涉及4种操作：

- 字节替代（SubBytes）：通过非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。
- 行移位（ShiftRows）：将矩阵中的每个横列进行循环式移位。
- 列混淆（MixColumns）：为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每列的四个字节。
- 轮密钥加（AddRoundKey）：矩阵中的每一个字节都与该次轮密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。

下图给出了AES加解密的流程，从图中可以看出：

1. 解密算法的每一步分别对应加密算法的逆操作；
2. 加解密所有操作的顺序正好是相反的。正是由于这几点（再加上加密算法与解密算法每步的操作互逆）保证了算法的正确性。加解密中每轮的密钥分别由种子密钥经过密钥扩展算法得到。算法中16字节的明文、密文和轮子密钥都以一个4x4的矩阵表示。

![image-20230612162901745](assets/image-20230612162901745.png)

#### 代码实现

```cpp
class CAes
{
public:
    CAes(const std::string& strKey);
    int Encrypt(const char* pInData, uint32_t nInLen, char** ppOutData, uint32_t& nOutLen);
    int Decrypt(const char* pInData, uint32_t nInLen, char** ppOutData, uint32_t& nOutLen);
    void Free(char* pData);
private:
    AES_KEY m_cEncKey;
    AES_KEY m_cDecKey;
};
```

```cpp
// 加解密秘钥设置
CAes::CAes(const std::string& strKey)
{
    AES_set_encrypt_key((const unsigned char*)strKey.c_str(), 256, &m_cEncKey);
    AES_set_decrypt_key((const unsigned char*)strKey.c_str(), 256, &m_cDecKey);
}

int CAes::Encrypt(const char* pInData, uint32_t nInLen, char** ppOutData, uint32_t& nOutLen)
{
    if (pInData == NULL || nInLen <= 0)
        return -1;

    uint32_t nRemain = nInLen % 16;
    uint32_t nBlocks = (nInLen + 15) / 16;

    if (nRemain > 12 || nRemain == 0)
        nBlocks += 1;
    uint32_t nEncryptLen = nBlocks * 16;

    // 加密前的数据
    unsigned char* pData = (unsigned char*)calloc(nEncryptLen, 1);
    memcpy(pData, pInData, nInLen);

    // 加密后的数据
    unsigned char* pEncData = (unsigned char*)malloc(nEncryptLen);
    CByteStream::WriteUint32((pData + nEncryptLen - 4), nInLen);
    for (uint32_t i = 0; i < nBlocks; i++)
        AES_encrypt(pData + i * 16, pEncData + i * 16, &m_cEncKey);

    free(pData);
    std::string strEnc((char*)pEncData, nEncryptLen);
    free(pEncData);

    // base64编码
    std::string strDec = base64_encode(strEnc);

    nOutLen = (uint32_t)strDec.length();
    char* pTmp = (char*)malloc(nOutLen + 1);
    memcpy(pTmp, strDec.c_str(), nOutLen);
    pTmp[nOutLen] = 0;

    *ppOutData = pTmp;

    return 0;
}

int CAes::Decrypt(const char* pInData, uint32_t nInLen, char** ppOutData, uint32_t& nOutLen)
{
    if (pInData == NULL || nInLen <= 0)
        return -1;

    std::string strInData(pInData, nInLen);

    // base64解码
    std::string strRet = base64_decode(strInData);
    uint32_t nLen = (uint32_t)strRet.length();
    if (nLen == 0)
        return -2;

    const unsigned char* pData = (const unsigned char*)strRet.c_str();

    // 待解密数据长度不是16倍数 数据不完整或格式错误 存在不完整的AES加密块
    if (nLen % 16 != 0)
        return -3;
    
    char* pTmp = (char*)malloc(nLen + 1);

    // 将数据进行分块AES解密
    uint32_t nBlocks = nLen / 16;
    for (uint32_t i = 0; i < nBlocks; i++)
        AES_decrypt(pData + i * 16, (unsigned char*)pTmp + i * 16, &m_cDecKey);

    // 解密后的数据长度不可大于原始长度
    uchar_t* pStart = (uchar_t*)pTmp + nLen - 4;
    nOutLen = CByteStream::ReadUint32(pStart);
    if (nOutLen > nLen) {
        free(pTmp);
        return -4;
    }

    pTmp[nOutLen] = 0;
    *ppOutData = pTmp;
    return 0;
}

void CAes::Free(char* pOutData)
{
    if (pOutData) {
        free(pOutData);
        pOutData = NULL;
    }
}
```



## Common-Group2

### atomic原子操作

```cpp
#ifndef _ATOMIC_H_
#define _ATOMIC_H_

// src_ptr + v
#define ATOMIC_ADD(src_ptr, v) (void)__sync_add_and_fetch(src_ptr, v)

// src_ptr + v
#define ATOMIC_ADD_AND_FETCH(src_ptr, v) __sync_add_and_fetch(src_ptr, v)

// src_ptr - v
#define ATOMIC_SUB_AND_FETCH(src_ptr, v) __sync_sub_and_fetch(src_ptr, v)

// src_ptr get
#define ATOMIC_FETCH(src_ptr) __sync_add_and_fetch(src_ptr, 0)

// src_ptr set
#define ATOMIC_SET(src_ptr, v) (void)__sync_bool_compare_and_swap(src_ptr, *(src_ptr), v)

typedef volatile long atomic_t;// 原子访问

#endif
```

#### 宏定义写法分析

关于这种宏定义写法的说明：宏定义是一种在预处理阶段进行文本替换的机制。

以`#define ATOMIC_ADD(src_ptr, v) (void)__sync_add_and_fetch(src_ptr, v)`为例：

1. 在这个宏定义中`ATOMIC_ADD(src_ptr, v)`是宏的名称，`(void)` 是返回类型，`__sync_add_and_fetch(src_ptr, v)`是宏的替换体
2. `__sync_add_and_fetch(src_ptr, v)` 是一个<font color='#BAOC2F'>内建函数</font>，用于执行原子的加法操作，并返回相加后的结果。该函数接受两个参数：`src_ptr` 是一个指针，表示要进行加法操作的内存位置；`v` 是要相加的值。`__sync_add_and_fetch` 函数将指针所指向的内存位置的值与 `v` 相加，并<font color='#BAOC2F'>将结果存回该内存位置</font>。最后，函数返回相加后的结果。
3. 宏定义的目的是<font color='#BAOC2F'>将函数调用和返回值类型包装在一个方便使用的宏中</font>，以便在代码中直接调用宏来执行相应的操作，而不需要显式调用函数。这种宏定义的写法可以<font color='#BAOC2F'>简化对内建函数的调用</font>，使代码更加简洁和易读。
4. 在这种写法中，`(void)` 表示该宏没有返回值，只执行加法操作而不获取返回结果。
5. 因此当在代码中使用 `ATOMIC_ADD(src_ptr, v)` 时，预处理器将会将其替换为 `(void)__sync_add_and_fetch(src_ptr, v)`，从而实现对应的原子加法操作

以`#define ATOMIC_ADD_AND_FETCH(src_ptr, v) __sync_add_and_fetch(src_ptr, v)`为例：

1. 这种写法没有明确声明返回值类型是因为 `__sync_add_and_fetch()` 是一个内建函数，它的<font color='#BAOC2F'>返回值类型是根据参数的类型来推导的</font>。在这种情况下，<font color='#BAOC2F'>返回值类型将与 src_ptr 指针所指向的内存位置的类型相匹配</font>。
2. 由于宏定义仅是对代码进行文本替换，因此无法在宏定义中明确指定返回值类型。预处理器只会将宏调用展开为相应的代码，而无法对代码进行类型检查。因此，使用这种写法时，需要确保 `src_ptr` 指针所指向的内存位置的类型与预期的操作和返回值类型是相容的。
3. 在使用 `ATOMIC_ADD_AND_FETCH(src_ptr, v)` 这样的宏时，应确保 `src_ptr` 指向的内存位置和 `v` 的类型是兼容的，并且使用该宏的上下文中可以正确处理返回值。

#### gcc内建函数

关于`__sync_add_and_fetch(src_ptr, v)` 与 `__sync_sub_and_fetch` 的说明：

`__sync_add_and_fetch`是GCC内建函数（GCC built-in function），属于GCC编译器提供的一组内建函数之一。

GCC内建函数提供了一些特定的原子操作，如原子加法、原子比较交换等。这些函数在编译时会被<font color='#BAOC2F'>直接转换为相应的硬件指令</font>或者<font color='#BAOC2F'>使用特定的处理器指令集</font>来实现原子操作。`__sync_add_and_fetch` 函数的具体实现取决于所使用的编译器和目标平台。

在实际开发项目中，`__sync_add_and_fetch` 函数可以在代码中直接使用，而无需特定的头文件或库。编译器会根据代码上下文自动识别并转换为相应的硬件指令或处理器指令，从而实现原子加法操作。

GCC提供了一系列的内建函数（built-in functions），用于提供特定的功能或操作。

除了 `__sync_add_and_fetch` 之外，GCC还提供了其他常用的内建函数，包括但不限于以下几个：

1. 原子操作函数：
    - `__sync_fetch_and_add`：执行原子加法操作并返回旧值。
    - `__sync_fetch_and_sub`：执行原子减法操作并返回旧值
    - `__sync_fetch_and_or`：执行原子按位或操作并返回旧值。
    - `__sync_fetch_and_and`：执行原子按位与操作并返回旧值。
    - `__sync_fetch_and_xor`：执行原子<font color='#BAOC2F'>按位异或操作</font>并返回旧值。
    - `__sync_bool_compare_and_swap`：执行原子<font color='#BAOC2F'>比较并交换</font>操作。
    - `__sync_val_compare_and_swap`：执行原子<font color='#BAOC2F'>比较并交换</font>操作，<font color='#BAOC2F'>并返回比较结果</font>。
2. 内存屏障函数：
    - `__sync_synchronize`：执行一个<font color='#BAOC2F'>全局的内存屏障</font>，确保内存操作按照顺序执行。

这些内建函数提供了一些原子操作和内存屏障功能，可以在多线程编程中使用，确保数据的一致性和线程安全性。

请注意，这些内建函数的使用可能会依赖于特定的编译器和目标平台。

建议查阅相关编译器文档或 GCC 官方文档以获取更详细的信息和完整的内建函数列表。

#### volatile关键字

用于声明一个变量是易变的（volatile variable）。它的作用是告诉编译器该变量的值<font color='#BAOC2F'>可能会在程序执行过程中被意外地改变</font>，因此编译器在对该变量的<font color='#BAOC2F'>读取和写入时应该遵循一些特定的规则</font>，以确保对变量的操作是准确的。

需要注意的是，`volatile` <font color='#BAOC2F'>并不能完全解决多线程编程中的并发访问问题</font>，它<font color='#BAOC2F'>只能确保对变量的读取和写入操作的可见性</font>。要实现线程安全，还需要使用其他的同步机制，如互斥锁（mutex）或原子操作。

`volatile` 的主要作用有两个方面：

1. 防止编译器进行优化：编译器在进行代码优化时会尽可能地将变量的读取和写入操作进行重排或优化，以提高程序的执行效率。然而，对于声明为 `volatile` 的变量，编译器会禁止对其进行优化，确保每次读取和写入都是直接对内存进行操作，而不是使用寄存器或缓存的副本。
2. 处理多线程或并发访问：在多线程或并发编程中，多个线程可能同时访问某个变量。如果不使用 `volatile` 关键字，编译器可能会对变量的读取和写入操作进行优化，导致某些线程无法及时感知到其他线程对变量的修改。通过使用 `volatile` 关键字，可以告诉编译器确保变量的读取和写入操作在多线程环境中具有可见性，从而避免潜在的并发访问问题。

总而言之，`volatile` 关键字用于告诉编译器该变量是易变的，需要遵循特定的规则进行读取和写入操作，以确保可见性和准确性。

在多线程编程中，可以与其他同步机制配合使用来确保线程安全性。

### Lock锁机制与自动锁管理类

![image-20230612182325706](assets/image-20230612182325706.png)

条件编译关于`CRITICAL_SECTION m_critical_section;`的解释：

`CRITICAL_SECTION` 是 Windows 操作系统提供的一种临界区（Critical Section）的同步对象，用于<font color='#BAOC2F'>实现线程间的互斥访问</font>。

- 在 C++ 中是一种<font color='#BAOC2F'>同步原语，用于保护临界区代码，</font>防止多个线程同时访问导致的数据竞争和不一致性。
- 在 Windows 平台上一是一种轻量级的同步机制，<font color='#BAOC2F'>相对于互斥锁（Mutex）而言，它的开销较小</font>，适用于同一进程内的线程同步。
- 是一个类成员变量，用于表示一个临界区对象。
- 该对象可以在多个成员函数中使用，以实现线程安全的访问。

临界区对象的使用一般涉及两个主要的操作：

1. 进入临界区：通过调用 `EnterCriticalSection` 函数来进入临界区，该操作会阻塞其他线程的进入，直到当前线程离开临界区。
2. 离开临界区：通过调用 `LeaveCriticalSection` 函数来离开临界区，该操作允许其他线程进入临界区。

使用临界区对象可以<font color='#BAOC2F'>在多线程环境中保护共享资源的访问</font>，确保只有一个线程可以同时进入临界区执行相关代码，从而<font color='#BAOC2F'>避免并发访问引发的数据竞争问题</font>。

```cpp
#ifndef __LOCK_H__
#define __LOCK_H__

#include "ostype.h"

class CLock
{
public:
    CLock();
    virtual ~CLock();

    void lock();
    void unlock();
    pthread_mutex_t& getMutex() { return m_lock; }
#ifndef _WIN32
    virtual bool try_lock();
#endif
private:
#ifdef _WIN32
	CRITICAL_SECTION    m_critical_section;
#else
    pthread_mutex_t     m_lock;
#endif
};

class CAutoLock
{
public:
    CAutoLock(CLock* pLock);
    virtual ~CAutoLock();
private:
    CLock* m_pLock;
};

////////////////////////////////////////////////////////// 读写锁
#ifndef _WIN32
class CRWLock
{
public:
    CRWLock();
    virtual ~CRWLock();

    void rlock();
    void wlock();
    void unlock();
    bool try_rlock();
    bool try_wlock();
private:
    pthread_rwlock_t m_lock;
};

class CAutoRWLock
{
public:
    CAutoRWLock(CRWLock* pLock, bool bRLock = true);
    virtual ~CAutoRWLock();
private:
    CRWLock* m_pLock;
};
#endif

#endif
```



### Condition条件变量

![image-20230613082005606](assets/image-20230613082005606.png)

```cpp
#ifndef __CONDITION_H__
#define __CONDITION_H__

#include "Lock.h"
#include <pthread.h>

class CCondition
{
public:
    CCondition(CLock* pLock);
    ~CCondition();

    void wait();
    bool waitTime(uint64_t nWaitTime);
    void notify();
    void notifyAll();
private:
    CLock*          m_pLock;
    pthread_cond_t  m_cond;
};

#endif
```



### Singleton单例模式

模板类 `Singleton`用于实现单例模式，

该模板类的特点如下：

1. 通过静态成员变量 `s_instance` 来保存单例对象的指针
2. 提供了静态的 `Instance()`、`GetInstance()` 和 `getInstance()` 方法来获取单例对象的引用或指针
3. 提供了静态的 `Destroy()` 方法用于销毁单例对象
4. 构造函数和析构函数被保护起来，确保只能通过单例模式获取对象，并防止外部直接创建对象
5. 提供了私有的 `CreateInstance()` 和 `DestroyInstance()` 方法，用于创建和销毁单例对象
6. 实现了私有的复制构造函数和赋值操作符，禁止拷贝和赋值操作

使用该模板类可以方便地实现各种类的单例模式，通过调用 `Instance()`、`GetInstance()` 或 `getInstance()` 方法获取单例对象的引用或指针，并通过 `Destroy()` 方法销毁单例对象。

请注意，该单例模式是线程不安全的，如果在多线程环境下使用，需要自行添加线程安全措施。

```cpp
#ifndef BASE_SINGLETON_H_
#define BASE_SINGLETON_H_

template<typename T>
class Singleton {
public:
    /**
     * 提供了静态的 Instance()、GetInstance() 和 getInstance() 方法来获取单例对象的引用或指针 这三个方法的区别在于命名风格
     * 这三个方法都用于获取单例对象的引用或指针，它们的实现逻辑是相同的：
     *  1.首先检查静态成员变量 s_instance 是否为 nullptr，即单例对象是否已经被创建
     *  2.如果s_instance是nullptr，则调用CreateInstance()方法创建单例对象，并将其赋值给 s_instance
     *  3.返回s_instance的引用或指针
    */
    static T& Instance() {
        if(Singleton::s_instance==0) Singleton::s_instance = CreateInstance();
        return *(Singleton::s_instance);
    }
    static T* GetInstance() {
        if(Singleton::s_instance==0) Singleton::s_instance = CreateInstance();
        return Singleton::s_instance;
    }
    static T* getInstance() {
        if(Singleton::s_instance==0) Singleton::s_instance = CreateInstance();
        return Singleton::s_instance;
    }
    /**
     * 提供了静态的 Destroy() 方法用于销毁单例对象,具体的实现逻辑如下：
     *  1.检查静态成员变量 s_instance 是否为 nullptr，即单例对象是否存在
     *  2.如果 s_instance 不为 nullptr，则调用 DestroyInstance() 方法销毁单例对象
     *  3.将 s_instance 设置为 nullptr，表示单例对象已被销毁
    */
    static void Destroy() {
        if(Singleton::s_instance!=0) {
            DestroyInstance(Singleton::s_instance);
            Singleton::s_instance=0;
        }
    }
    
protected:
    /**
     * 构造函数和析构函数被保护起来，确保只能通过单例模式获取对象，并防止外部直接创建对象
     * 这里的构造函数和析构函数是保护（protected）的，因此只能在派生类中使用，不能直接在外部实例化或销毁单例对象
     * 这是为了确保单例对象的控制权和唯一性，只能通过 Instance() 或 GetInstance() 方法来获取单例对象的引用或指针
    */
    Singleton()	{
        //构造函数在创建单例对象时被调用
        //将当前对象的指针转换为 T* 类型，并将其赋值给静态成员变量 s_instance
        //确保单例对象在整个程序中只有一个实例，并且可以通过静态成员函数访问该实例
        Singleton::s_instance = static_cast<T*>(this);
    }
    ~Singleton() {
        //析构函数在销毁单例对象时被调用
        //将静态成员变量 s_instance 设置为 nullptr，表示单例对象已被销毁
        Singleton::s_instance = 0;
    }
    
private:
    //提供了私有的 CreateInstance() 和 DestroyInstance() 方法，用于创建和销毁单例对象
    static T* CreateInstance(){
        return new T();
    }
    static void DestroyInstance(T* p) {
        delete p;
    }
    
private:
    //通过静态成员变量 s_instance 来保存单例对象的指针
    static T *s_instance;
    
private:
    //实现私有的拷贝构造函数和赋值操作符，默认禁止拷贝和赋值操作
    /**
     * 私有的拷贝构造函数确保无法从单例对象创建新的副本
     * 构造函数的参数是 Singleton const & 类型，表示拷贝构造函数接受一个常量引用
     * 将构造函数声明为 explicit 是为了避免隐式的拷贝构造，只能在类内部访问
    */
    explicit Singleton(Singleton const &) { }
    /**
     * 私有的赋值操作符确保无法通过赋值操作将一个单例对象赋值给另一个对象
     * 赋值操作符的参数是 Singleton const & 类型，表示赋值操作符接受一个常量引用
     * 在赋值操作符的实现中，直接返回 *this，即当前对象的引用
    */
    Singleton& operator=(Singleton const&) { return *this; }
};

template<typename T>
T* Singleton<T>::s_instance=0;

#endif
```

### ConfigFileReader配置读取

![image-20230613092251440](assets/image-20230613092251440.png)

```cpp
class CConfigFileReader
{
public:
    CConfigFileReader(const char* file_path);
    ~CConfigFileReader();

    char*   GetConfigName(const char* key);
    bool    SetConfigValue(const char* key, const char* value);
private:
    bool        _LoadFile(const char* file_path);
    bool        _WriteFIle(const char* file_path = NULL);
    void        _ParseLine(char* line);
    char*       _TrimSpace(char* str);

    bool                                m_load_ok;          //是否加载成功
    std::string                         m_config_file;      //配置文件路径
    std::map<std::string, std::string>  m_config_map;       //配置存储
};
```



### util工具

![image-20230613084152477](assets/image-20230613084152477.png)

<mark>为什么要设计CRefObject类</mark>？

`CRefObject` 类的设计是为了实现引用计数机制，用于管理对象的生命周期和资源释放。

引用计数是一种常见的内存管理技术，通过在对象中维护一个计数器，记录当前有多少个指针引用了该对象，从而在合适的时机进行对象的释放。

引用计数机制的优点包括：

1. 自动内存管理：通过引用计数，对象的创建和销毁可以自动进行，减轻了手动管理内存的负担。当没有任何指针引用该对象时，引用计数为0，可以安全地释放对象占用的内存。
2. 避免悬挂指针：引用计数机制可以防止悬挂指针的问题，即当一个指针引用了一个已经被销毁的对象时，可以通过引用计数进行判断，在对象销毁时将所有引用指针置为无效，避免了访问无效对象的问题。
3. 支持共享所有权：多个指针可以共享同一个对象的所有权，通过增加和减少引用计数来管理对象的生命周期。这样可以实现对象在多个地方被引用和共享，而无需手动跟踪和协调对象的创建和销毁。

`CRefObject` 类作为基类，提供了引用计数的基本功能，包括引用计数的增加、减少和获取当前引用计数的方法。其他的类可以继承 `CRefObject` 类，从而获得引用计数功能，并在需要时覆写 `ReleaseRef` 方法来自定义对象释放的逻辑。

通过引用计数机制，可以简化对象的管理和释放，提高代码的可维护性和健壮性，同时避免了常见的内存管理问题。

```cpp
class CRefObject
{
public:
    CRefObject();
    virtual ~CRefObject();

    void SetLock(CLock* lock) { m_lock = lock; }

    void AddRef();
    void ReleaseRef();
private:
    int     m_refCount;
    CLock*  m_lock;
};
```

```cpp
// 字符串分割类
class CStrExplode
{
public:
    CStrExplode(char* str, char seperator);
    virtual ~CStrExplode();
    
    uint32_t GetItemCnt() { return m_item_cnt; }
    char* GetItem(uint32_t idx) { return m_item_list[idx]; }
private:
    uint32_t    m_item_cnt;     //子字符串数量
    char**      m_item_list;    //子字符串
};
```



## Group3线程池

### Task

CTask类是一个抽象基类，用于表示任务的概念，只能用作其他具体任务类的基类 派生类必须实现run()函数来定义任务的具体逻辑。

通过派生类的实现，可以创建不同类型的任务对象，并通过调用run()函数来执行任务的逻辑。

这样的设计允许在任务执行过程中的多态行为，以便针对不同的任务类型执行不同的操作。

```cpp
#ifndef __TASK_H__
#define __TASK_H__

class CTask
{
public:
    CTask(){}
    virtual ~CTask(){}
    
    virtual void run() = 0;
private:
};

#endif
```

### Thread

![image-20230613093608419](assets/image-20230613093608419.png)

```cpp
#ifndef __THREAD_H__
#define __THREAD_H__

#include <pthread.h>

/**
 * @brief 
 * CThread线程类封装
 * 实现OnThreadRun函数来定义线程行为
 */
class CThread
{
public:
    CThread();
    virtual ~CThread();

#ifdef _WIN32
    static DWORD WINAPI StartRoutine(LPVOID lpParameter);
#else
    static void* StartRoutine(void* arg);
#endif

    virtual void StartThread(void);
    virtual void OnThreadRun(void) = 0;

protected:
#ifdef _WIN32
    DWORD       m_thread_id;
#else
    pthread_t   m_thread_id;//线程的标识符
#endif
};

/**
 * @brief
 * 针对CThread的扩展
 * 实现OnThreadTick函数来定义线程行为
 */
class CEventThread : public CThread
{
public:
    CEventThread();
    virtual ~CEventThread();

    virtual void OnThreadTick(void) = 0;//线程任务逻辑
    virtual void OnThreadRun(void);
    virtual void StartThread();
    virtual void StopThread();

    bool IsRunning() { return m_bRunning; }
private:
    bool m_bRunning;
};

// 线程同步
class CThreadNotify
{
public:
    CThreadNotify();
    ~CThreadNotify();

    void Lock() { pthread_mutex_lock(&m_mutex); }
    void Unlock() { pthread_mutex_unlock(&m_mutex); }
    void Wait() { pthread_cond_wait(&m_cond, &m_mutex); }
    void Signal() { pthread_cond_signal(&m_cond); }

private:
    pthread_mutex_t         m_mutex;
    pthread_mutexattr_t     m_mutexattr;
    pthread_cond_t          m_cond;
};

#endif
```



### ThreadPool

使用现有线程库（pthread.h）实现一个工作线程池，工作线程使用std::list实现任务队列，使用条件变量来解决生产者消费者的竞争问题 

![image-20230613103836992](assets/image-20230613103836992.png)

```cpp
#ifndef THREADPOOL_H_
#define THREADPOOL_H_

#include <list>
#include <pthread.h>
#include "Task.h"
#include "Thread.h"
#include "common/ostype.h"

class CWorkerThread
{
public:
	CWorkerThread();
	~CWorkerThread();

	static void* StartRoutine(void* arg);

	void Start();
	void Execute();
	void PushTask(CTask* pTask);
	void SetThreadIdx(uint32_t idx) { m_thread_idx = idx; }
private:
	uint32_t			m_thread_idx;		//线程idx
	uint32_t			m_task_cnt;			//任务数量
	pthread_t			m_thread_id;		//线程id
	CThreadNotify		m_thread_notify;	//线程通知对象，用于线程同步
	std::list<CTask*>	m_task_list;		//线程任务队列
};

class CThreadPool
{
public:
	CThreadPool();
	virtual ~CThreadPool();

	int Init(uint32_t worker_size);
	void AddTask(CTask* pTask);
	void Destory();
private:
	uint32_t 		m_worker_size;		//线程池大小
	CWorkerThread* 	m_worker_list;		//线程池数组
};

#endif
```



## Group4HTTP请求处理

### HttpParser

http解析实际上是利用了ngnix的http_parse解析库，http_parse为HTTP解析器定义了HTTP解析器的结构体、枚举值和相关函数的声明

头文件提供了HTTP解析器的相关声明和常量定义，可以在其他源文件中包含该头文件以使用HTTP解析器功能。

- 定义了`http_parser`结构体，表示HTTP解析器的状态和相关信息。
- 定义了`http_parser_settings`结构体，用于设置HTTP解析器的回调函数。
- 定义了`http_method`枚举，表示HTTP请求方法。
- 定义了一些常量，如HTTP解析器的版本号、最大报文头大小等。
- 定义了一些错误码的枚举值和错误相关的宏。
- 声明了HTTP解析器的相关操作函数：提供了对HTTP解析器的初始化、执行解析、获取解析结果等功能
    - unsigned long http_parser_version(void)`：获取HTTP解析器的版本号
    - void http_parser_init(http_parser *parser, enum http_parser_type type)`：初始化HTTP解析器
    - size_t http_parser_execute(http_parser *parser, const http_parser_settings *settings, const char *data, size_t len)`：执行HTTP解析器，解析给定的数据
    - int http_should_keep_alive(const http_parser *parser)`：检查解析器是否应保持连接
    - const char *http_method_str(enum http_method m)`：将给定的HTTP方法枚举值转换为字符串表示。
    - const char *http_errno_name(enum http_errno err)：返回给定错误码的名称。
    - const char *http_errno_description(enum http_errno err)`：返回给定错误码的描述。
    - int http_parser_parse_url(const char *buf, size_t buflen, int is_connect, struct http_parser_url *u)`：解析URL，并填充`http_parser_url`结构体。
    - void http_parser_pause(http_parser *parser, int paused)`：暂停或恢复解析器的解析过程。
    - int http_body_is_final(const http_parser *parser)`：检查当前报文体是否为最后一个块。

### HttpParserWrapper

```cpp
class CHttpParserWrapper
{
public:
    CHttpParserWrapper();
    virtual ~CHttpParserWrapper() {}
    
    void ParseHttpContent(const char* buf, uint32_t len);

    bool IsReadAll() { return m_read_all; }
    bool IsReadReferer() { return m_read_referer; }
    bool HasReadReferer() { return m_referer.size() > 0; }

    bool IsReadForwardIP() { return m_read_forward_ip; }
    bool HasReadForwardIP() { return m_forward_ip.size() > 0; }

    bool IsReadUserAgent() { return m_read_user_agent; }
    bool HasReadUserAgent() { return m_user_agent.size() > 0; }

    bool IsReadContentType() { return m_read_content_type;  }
    bool HasReadContentType() { return m_content_type.size() > 0; }

    bool IsReadContentLen()  { return m_read_content_len; }
    bool HasReadContentLen() { return m_content_len != 0; }

    bool IsReadHost()  { return m_read_host;  }
    bool HasReadHost() { return m_host.size()>0; }

    // total_length
    uint32_t GetTotalLength() { return m_total_length; }
    void SetTotalLength(uint32_t total_len) { m_total_length = total_len; }

    // url
    char* GetUrl() { return (char*)m_url.c_str(); }
    void SetUrl(const char* url, size_t length) { m_url.append(url, length); }

    // body_content
    char* GetBodyContent() { return (char*)m_body_content.c_str(); }
    uint32_t GetBodyContentLen() { return (uint32_t)m_body_content.length(); }
    void SetBodyContent(const char* content, size_t length) { m_body_content.append(content, length); }

    // referer
    char* GetReferer() { return (char*)m_referer.c_str(); }
    void SetReferer(const char* referer, size_t length) { m_referer.append(referer, length); }

    // forward_ip
    char* GetForwardIP() { return (char*)m_forward_ip.c_str(); }
    void SetForwardIP(const char* forward_ip, size_t length) { m_forward_ip.append(forward_ip, length); }

    // user_agent
    char* GetUserAgent() { return (char*)m_user_agent.c_str(); }
    void SetUserAgent(const char* user_agent, size_t length) { m_user_agent.append(user_agent, length); }

    // content_type
    char* GetContentType() { return (char*) m_content_type.c_str(); }
    void SetContentType(const char* content_type, size_t length) {  m_content_type.append(content_type, length); }

    // content_len
    uint32_t  GetContentLen() { return m_content_len; }
    void SetContentLen(uint32_t content_len) { m_content_len = content_len; }
    
    // host
    char* GetHost() { return (char*) m_host.c_str(); }
    void SetHost(const char* host, size_t length) { m_host.append(host, length); }
    
    // read_content
    void SetReadContentType(bool read_content_type) { m_read_content_type =  read_content_type; }
    void SetReadContentLen(bool read_content_len) { m_read_content_len = read_content_len; }

    // read_host
    void SetReadHost(bool read_host) { m_read_host = read_host; }
    void SetReadAll() { m_read_all = true; }
    void SetReadReferer(bool read_referer) { m_read_referer = read_referer; }
    void SetReadForwardIP(bool read_forward_ip) { m_read_forward_ip = read_forward_ip; }
    void SetReadUserAgent(bool read_user_agent) { m_read_user_agent = read_user_agent; }
    
    char GetMethod() { return (char) m_http_parser.method; }

    // 解析过程回调函数
    static int OnUrl(http_parser* parser, const char *at, size_t length, void* obj);
    static int OnHeaderField(http_parser* parser, const char *at, size_t length, void* obj);
    static int OnHeaderValue(http_parser* parser, const char *at, size_t length, void* obj);
    static int OnHeadersComplete (http_parser* parser, void* obj);
    static int OnBody (http_parser* parser, const char *at, size_t length, void* obj);
    static int OnMessageComplete (http_parser* parser, void* obj);

private:
    http_parser m_http_parser;              //HTTP解析器对象，用于解析HTTP请求
    http_parser_settings m_settings;        //HTTP解析器的设置，包含回调函数等配置信息

    bool m_read_all;                        //是否已读取全部的字段
    bool m_read_referer;                    //是否已读取Referer字段
    bool m_read_forward_ip;                 //是否已读取Forward IP字段
    bool m_read_user_agent;                 //是否已读取User-Agent字段
    bool m_read_content_type;               //是否已读取Content-Type字段
    bool m_read_content_len;                //是否已读取Content-Length字段
    bool m_read_host;                       //是否已读取Host字段

    uint32_t m_total_length;                //HTTP请求的总长度
    std::string	m_url;                      //请求的URL
    std::string	m_body_content;             //请求的消息体内容
    std::string	m_referer;                  //Referer字段的值，表示请求的来源
    std::string m_forward_ip;               //请求经过的代理服务器的IP
    std::string m_user_agent;               //发起请求的用户代理(浏览器、应用程序等)
    std::string m_content_type;             //请求消息体的类型
    uint32_t  m_content_len;                //请求消息体的长度
    std::string m_host;                     //请求的目标主机
};
```

### HttpClient

CURL（Client for URLs）是一个开源的<font color='#BAOC2F'>用于传输数据的库</font>，支持多种协议HTTP、FTP、SMTP等。它提供了一组丰富的功能和接口，用于进行网络通信和数据传输操作。在C语言程序中使用CURL库，可以实现各种网络操作如发送HTTP请求、下载文件、上传文件、处理网络数据等。CURL库提供了丰富的选项和配置，允许开发者进行高度定制和灵活控制网络通信过程。HttpClient利用<font color='#BAOC2F'>curl库</font>和<font color='#BAOC2F'>jsoncpp</font>实现了<font color='#BAOC2F'>http客户端Get/Post和语音数据的上传下载</font>，

```cpp
#ifndef _HTTP_CLIENT_H_
#define _HTTP_CLIENT_H_

#include <string>
#include <curl/curl.h>
#include "public_define.h"

class CHttpClient
{
public:
    CHttpClient(void);
    ~CHttpClient(void);
public:
    CURLcode Post(const std::string & strUrl, const std::string & strPost, std::string & strResponse);
    CURLcode Get(const std::string & strUrl, std::string & strResponse);
    // 语音数据上传下载
    std::string UploadByteFile(const std::string &url, void* data, int data_len);
    bool DownloadByteFile(const std::string &url, AudioMsgInfo* pAudioMsg);
};

#endif // _HTTP_CLIENT_H_
```



## Group5具体业务处理

### 数据包处理UtilPdu

字节是通过网络传输信息（或在硬盘或内存中存储信息）的单位，该模块实现了字节流数据处理的一些工具类。

![image-20230612111015358](assets/image-20230612111015358.png)

#### CPduException

```cpp
/**
 * CPduException 类用于处理 PDU 过程中的异常情况 以便捕获和处理错误情况
 * 通过获取异常对象的属性，可以获取有关错误的详细信息，如服务ID、命令ID、错误代码和错误消息，从而进行相应的错误处理
*/
class CPduException {
public:
	CPduException(uint32_t service_id, uint32_t command_id, uint32_t error_code, const char* error_msg) {
		m_service_id = service_id;
		m_command_id = command_id;
		m_error_code = error_code;
		m_error_msg = error_msg;
	}
	CPduException(uint32_t error_code, const char* error_msg) {
		m_service_id = 0;
		m_command_id = 0;
		m_error_code = error_code;
		m_error_msg = error_msg;
	}
	virtual ~CPduException() {}

	uint32_t GetServiceId() { return m_service_id; }
	uint32_t GetCommandId() { return m_command_id; }
	uint32_t GetErrorCode() { return m_error_code; }
	char* GetErrorMsg() { return (char*)m_error_msg.c_str(); }
private:
	uint32_t	m_service_id;
	uint32_t	m_command_id;
	uint32_t	m_error_code;
	string		m_error_msg;
};
```

#### CSimpleBuffer

```cpp
/**
 * CSimpleBuffer 类提供一个简单的缓冲区实现，用于在内存中存储数据
 * 可以通过扩展缓冲区的大小来适应不断增长的数据量，并提供了写入和读取数据的方法，方便进行数据的存储和读取操作
 * 用于网络通信或数据序列化等场景，提供了基本的缓冲区功能。
*/
class DLL_MODIFIER CSimpleBuffer
{
public:
	CSimpleBuffer();
	~CSimpleBuffer();
	
	uchar_t*  	GetBuffer() { return m_buffer; }
	uint32_t 	GetAllocSize() { return m_alloc_size; }
	uint32_t 	GetWriteOffset() { return m_write_offset; }
	void 		IncWriteOffset(uint32_t len) { m_write_offset += len; }

	bool 		Extend(uint32_t len);
	uint32_t 	Write(void* buf, uint32_t len);
	uint32_t 	Read(void* buf, uint32_t len);
private:
	uchar_t*	m_buffer;			//缓冲区指针
	uint32_t	m_alloc_size;		//缓冲区大小
	uint32_t	m_write_offset;		//写入偏移量 
};
```

#### CByteStream

```cpp
/**
 * CByteStream类提供了一些方便的方法来读取和写入不同类型的数据（例如整数、字符串、字节数组）到缓冲区中 以及从缓冲区中读取数据
 * 这些方法可以帮助简化数据的序列化和反序列化过程。
*/
// 封装了二进制读写的流式操作类
class CByteStream
{
public:
	CByteStream(uchar_t* buf, uint32_t len);
	CByteStream(CSimpleBuffer* pSimpBuf, uint32_t pos);
	~CByteStream() {}

	// 获取缓冲区
	unsigned char* GetBuf() { return m_pSimpBuf ? m_pSimpBuf->GetBuffer() : m_pBuf; }
	// 当前读写位置
	uint32_t GetPos() { return m_pos; }
	// 缓冲区的长度
	uint32_t GetLen() { return m_len; }
	// 读写位置后移
	bool Skip(uint32_t len);

	// 字节数组转换
	static int16_t ReadInt16(uchar_t* buf);
	static int32_t ReadInt32(uchar_t* buf);
	static uint16_t ReadUint16(uchar_t* buf);
	static uint32_t ReadUint32(uchar_t* buf);

	static void WriteInt16(uchar_t* buf, int16_t data);
	static void WriteInt32(uchar_t* buf, int32_t data);	
	static void WriteUint16(uchar_t* buf, uint16_t data);
	static void WriteUint32(uchar_t* buf, uint32_t data);

	// 缓冲区数据写入
	void operator << (int8_t data);
	void operator << (int16_t data);
	void operator << (int32_t data);
	void operator << (uint8_t data);
	void operator << (uint16_t data);
	void operator << (uint32_t data);

	// 缓冲区数据读取
	void operator >> (int8_t& data);
	void operator >> (int16_t& data);
	void operator >> (int32_t& data);
	void operator >> (uint8_t& data);
	void operator >> (uint16_t& data);
	void operator >> (uint32_t& data);
	
	// char*
	void WriteString(const char* str);
	void WriteString(const char* str, uint32_t len);
	char* ReadString(uint32_t& len);

	// unsigned char
	void WriteData(uchar_t* data, uint32_t len);
	uchar_t* ReadData(uint32_t& len);
private:
	void _WriteByte(void* buf, uint32_t len);
	void _ReadByte(void* buf, uint32_t len);
private:
	CSimpleBuffer*	m_pSimpBuf;		//CSimpleBuffer指针
	uchar_t*		m_pBuf;			//缓冲区的指针
	uint32_t		m_len;			//缓冲区长度
	uint32_t		m_pos;			//读写位置
};
```

#### idtourl

URL字符串与uint32_t类型互相转换，可用于特定的应用场景，例如：

1. 缩短URL：将长的URL转换为短的uint32_t类型的整数表示，可以减小URL的长度，方便传输和存储。
2. 数据索引：将URL映射为唯一的uint32_t标识符，可以用于在数据库或索引中进行快速的查找和检索操作。
3. 数据加密：将敏感的URL信息转换为无意义的uint32_t类型的值，以保护数据的安全性和隐私性。
4. 内部数据处理：在内部数据处理过程中，将URL字符串转换为uint32_t类型的整数可以加快计算速度和减少存储空间。

总的来说，URL字符串与uint32_t类型的互相转换可以在某些场景下提供更高效、更紧凑的数据表示和处理方式。具体应用取决于具体需求和业务场景。

```cpp
// 将一个uint32_t类型的整数转换为对应的URL字符串
char* idtourl(uint32_t id) {
    // 1.用于转换的数字和字母字符
    static char digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
    static char buf[64];
    char* ptr;
    uint32_t value = id * 2 + 56;
    // convert to 36 number system
    ptr = buf + sizeof(buf) - 1;
    *ptr = '\0';

    // 2.循环直到 value 为 0 或者缓冲区指针 ptr 到达缓冲区的起始位置
    do {
        *--ptr = digits[value % 36];
        value /= 36;
    } while (ptr > buf && value);

    // 3.在转换结束后，在缓冲区的最前面添加版本号字符1
    *--ptr = '1'; // add version number

    // 4.返回指向缓冲区的指针ptr
    return ptr;
}

//将URL字符串转换为对应的uint32_t类型的整数
uint32_t urltoid(const char* url) {
    uint32_t url_len = strlen(url);
    char c;
    uint32_t number = 0;//用于存储转换结果的中间值
    for (uint32_t i = 1; i < url_len; i++) {
        //从URL字符串的第二个字符开始遍历（跳过版本号字符1）直到字符串末尾
        c = url[i];
        if (c >= '0' && c <= '9') c -= '0';
        else if (c >= 'a' && c <= 'z') c -= 'a' - 10;
        else if (c >= 'A' && c <= 'Z') c -= 'A' - 10;
        else continue;
        number = number * 36 + c;
    }
    return (number - 56) >> 1;
}
```



### 数据包ImPduBase

ImPduBase用于<font color='#BAOC2F'>通讯数据包的读取解析</font>，依赖于UtilPdu工具类，依赖于protobuf第三方库，

![image-20230614080513841](assets/image-20230614080513841.png)

```cpp
typedef struct {
    uint32_t 	length;     // 协议包长度
    uint16_t 	version;    // 协议版本号
    uint16_t	flag;       // 未使用
    uint16_t	service_id; // 服务id
    uint16_t	command_id; // 命令id
    uint16_t	seq_num;    // 包序号
    uint16_t    reversed;   // 预留字段
} PduHeader_t;

class DLL_MODIFIER CImPdu
{
public:
    CImPdu();
    virtual ~CImPdu() {}
    
    uchar_t* GetBuffer();
    uint32_t GetLength();
    uchar_t* GetBodyData();
    uint32_t GetBodyLength();
    
    uint16_t GetVersion() { return m_pdu_header.version; }
    uint16_t GetFlag() { return m_pdu_header.flag; }
    uint16_t GetServiceId() { return m_pdu_header.service_id; }
    uint16_t GetCommandId() { return m_pdu_header.command_id; }
    uint16_t GetSeqNum() { return m_pdu_header.seq_num; }
    uint32_t GetReversed() { return m_pdu_header.reversed; }
    
    void SetVersion(uint16_t version);
    void SetFlag(uint16_t flag);
    void SetServiceId(uint16_t service_id);
    void SetCommandId(uint16_t command_id);
    void SetError(uint16_t error);
    void SetSeqNum(uint16_t seq_num);
    void SetReversed(uint32_t reversed);
    
    // PDU完整性检查
    static bool IsPduAvailable(uchar_t* buf, uint32_t len, uint32_t& pdu_len);
    // PDU完整解析
    static CImPdu* ReadPdu(uchar_t* buf, uint32_t len);
    // PDU头部写入
    void WriteHeader();
    // PDU头部解析
    int ReadPduHeader(uchar_t* buf, uint32_t len);
    // 缓冲区数据写入
    void Write(uchar_t* buf, uint32_t len) { m_buf.Write((void*)buf, len); }
    // 将Protobuf消息设置为当前消息体
    bool SetPBMsg(const google::protobuf::MessageLite* msg);
    
protected:
    CSimpleBuffer	m_buf;          // 消息
    PduHeader_t		m_pdu_header;   // 消息头
};
```



### 连接管理imconn

利用netlib封装了一套<font color='#BAOC2F'>通用的tcp连接基础类</font>，

业务类的连接像CLoginConn用于登录服务器连接和CHttpConn用于http连接等<font color='#BAOC2F'>可继承该类重写自己的业务逻辑</font>。

![image-20230614082300718](assets/image-20230614082300718.png)

CImConn 类封装了对网络连接的管理和事件处理，

提供了发送和接收数据的功能，并定义了一些虚拟函数供派生类进行重写以实现特定的业务逻辑，

```cpp
#ifndef _IMCONN_H_
#define _IMCONN_H_

#include <unordered_map>
#include "util.h"
#include "netlib.h"
#include "ImPduBase.h"

#define SERVER_HEARTBEAT_INTERVAL	5000
#define SERVER_TIMEOUT				30000
#define CLIENT_HEARTBEAT_INTERVAL	30000
#define CLIENT_TIMEOUT				120000
#define MOBILE_CLIENT_TIMEOUT       60000 * 5
#define READ_BUF_SIZE				2048

/**
 * @brief CImConn
 * 1.提供发送和接收数据的功能
 * 2.封装了对网络连接的管理 和事件处理
 * 3.通过继承CImConn对象 来实现具体的业务逻辑
 * 4.每个TCP长连接都需要绑定一个CImConn对象(Socket)
 */
class CImConn : public CRefObject
{
public:
	CImConn();
	virtual ~CImConn();

	bool IsBusy() { return m_busy; }

	// 数据发送
	int Send(void* data, int len);
	int SendPdu(CImPdu* pPdu) { return Send(pPdu->GetBuffer(), pPdu->GetLength()); }

	// 回调处理连接的事件
	virtual void OnConnect(net_handle_t handle) { m_handle = handle; }	// 连接建立
	virtual void OnConfirm() {}							// 连接确认
	virtual void OnRead();								// 数据读取	
	virtual void OnWrite();								// 数据写入
	virtual void OnClose() {}							// 连接关闭
	virtual void OnTimer(uint64_t curr_tick) {}			// 定时器事件
    virtual void OnWriteCompelete() {};					// 写入完成事件

	// 处理连接接收到的CImPdu对象
	virtual void HandlePdu(CImPdu* pPdu) {}

protected:
	net_handle_t	m_handle;				//网络句柄，用于标识连接 int类型
	bool			m_busy;					//连接是否处于忙碌状态

	std::string		m_peer_ip;				//对端IP地址
	uint16_t		m_peer_port;			//对端端口号

	CSimpleBuffer	m_in_buf;				//输入缓冲区
	CSimpleBuffer	m_out_buf;				//输出缓冲区

	bool			m_policy_conn;			//连接是否为策略连接
	uint32_t		m_recv_bytes;			//已接收的字节数
	uint64_t		m_last_send_tick;		//最后一次发送数据的时间戳
	uint64_t		m_last_recv_tick;		//最后一次接收数据的时间戳
    uint64_t        m_last_all_user_tick;	//最后一次处理所有用户的时间戳
};

// CImConn对象与TCP连接绑定
typedef std::unordered_map<net_handle_t, CImConn*> ConnMap_t;

// CImConn对象与用户id绑定
typedef std::unordered_map<uint32_t, CImConn*> UserMap_t;

// CImConn对象根据不同消息类型 分发事件处理
void imconn_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam);

#endif // _IMCONN_H_
```



### 连接管理工具im_conn_util

这些函数提供了便捷的方式来发送使用Google Protocol Buffers库定义的消息对象，

通过传入连接对象、服务id、命令id等参数，可以将消息对象 转换为字节流并发送给对应的连接，

```cpp
#ifndef BASE_IM_CONN_UTIL_H_
#define BASE_IM_CONN_UTIL_H_

#include "common/ostype.h"

namespace google {
    namespace protobuf {
        class MessageLite;
    }
}
class CImConn;

// 将消息对象转换为字节流 并发送给对应的连接
int SendMessageLite(CImConn* conn, uint16_t sid, uint16_t cid, const ::google::protobuf::MessageLite* message);
int SendMessageLite(CImConn* conn, uint16_t sid, uint16_t cid, uint16_t seq_num, const ::google::protobuf::MessageLite* message);
int SendMessageLite(CImConn* conn, uint16_t sid, uint16_t cid, uint16_t seq_num, uint16_t error, const ::google::protobuf::MessageLite* message);

#endif
```



### 服务器信息ServInfo

```cpp
#ifndef SERVINFO_H_
#define SERVINFO_H_

#include "util.h"
#include "impdu/imconn.h"
#include "ConfigFileReader.h"

#define MAX_RECONNECT_CNT 64    //最大重连次数
#define MIN_RECONNECT_CNT 4     //最小重连次数

//服务器信息结构体
typedef struct {
    std::string server_ip;      //IP
    uint16_t    server_port;    //端口
    uint32_t    idle_cnt;       //空闲计数
    uint32_t    reconnect_cnt;  //重连计数
    CImConn*    serv_conn;      //服务器连接对象
} serv_info_t;

/**
 * 这个函数通过模板参数T可以适配不同类型的服务器连接对象，例如CImConn
 * 其遍历服务器列表，为每个服务器创建连接对象并初始化相关参数，以便后续使用
*/
/// @brief 函数模板定义 用于初始化服务器连接对象
/// @tparam T 服务器连接对象的类型
/// @param server_list 指向服务器信息结构体数组的指针
/// @param server_count 服务器信息结构体数组的大小
template <class T>
void serv_init(serv_info_t* server_list, uint32_t server_count) {
    //遍历服务器信息结构体数组
    for (uint32_t i = 0; i < server_count; i++) {
        //对于每个服务器，创建一个类型为T的服务器连接对象
        T* pConn = new T();
        //调用服务器连接对象的Connect方法，传入服务器的IP地址、端口号和序号i
        pConn->Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i);
        //将服务器连接对象赋值给相应的服务器信息结构体的serv_conn成员
        server_list[i].serv_conn = pConn;
        //将服务器信息结构体的idle_cnt设置为0
        server_list[i].idle_cnt = 0;
        //将服务器信息结构体的reconnect_cnt设置为MIN_RECONNECT_CNT / 2
        server_list[i].reconnect_cnt = MIN_RECONNECT_CNT / 2;
    }
}

/**
 * 这个函数通过模板参数T可以适配不同类型的服务器连接对象，例如CImConn。
 * 遍历服务器列表，检查每个服务器的连接状态，如果连接断开且达到了重连的条件，就创建新的连接对象并进行重新连接
*/
/// @brief 函数模板定义 用于检查服务器连接对象是否需要重新连接
/// @tparam T 服务器连接对象的类型
/// @param server_list 指向服务器信息结构体数组的指针
/// @param server_count 服务器信息结构体数组的大小
template <class T>
void serv_check_reconnect(serv_info_t* server_list, uint32_t server_count) {
    T* pConn;
    //遍历服务器信息结构体数组
    for (uint32_t i = 0; i < server_count; i++) {
        //获取服务器连接对象指针，并将其转换为类型为T*
        pConn = (T*)server_list[i].serv_conn;
        //如果连接对象为空指针，表示连接已断开 尝试进行重新连接
        if (!pConn) {
            //将服务器信息结构体的idle_cnt加1
            server_list[i].idle_cnt++;
            //如果idle_cnt达到了重连的次数阈值
            if (server_list[i].idle_cnt >= server_list[i].reconnect_cnt) {
                //创建一个类型为T的服务器连接对象
                pConn = new T();
                //调用连接对象的Connect方法，传入服务器的IP地址、端口号和序号（i）
                pConn->Connect(server_list[i].server_ip.c_str(), server_list[i].server_port, i);
                //将连接对象赋值给相应的服务器信息结构体的serv_conn成员
                server_list[i].serv_conn = pConn;
            }
        }
    }
}

/**
 * 这个函数通过模板参数T可以适配不同类型的服务器连接对象，例如CImConn。
 * 根据给定的服务器索引重置相应服务器的连接对象状态，包括将连接对象设为NULL、重置空闲计数器、调整重连次数等
*/
/// @brief 函数模板定义 用于重置服务器连接对象的状态
/// @tparam T 服务器连接对象的类型
/// @param server_list 指向服务器信息结构体数组的指针
/// @param server_count 服务器信息结构体数组的大小
/// @param serv_idx 要重置的服务器的索引
template <class T>
void serv_reset(serv_info_t* server_list, uint32_t server_count, uint32_t serv_idx) {
    //首先检查要重置的服务器的索引是否超出了数组的范围，如果超出则直接返回
    if (serv_idx >= server_count) return;
    //将服务器信息结构体的serv_conn成员设置为NULL，表示连接已断开
    server_list[serv_idx].serv_conn = NULL;
    //将服务器信息结构体的idle_cnt重置为0，表示空闲计数器归零
    server_list[serv_idx].idle_cnt = 0;
    //将服务器信息结构体的reconnect_cnt乘以2，表示下次重连的次数将增加一倍
    server_list[serv_idx].reconnect_cnt *= 2;
    //如果重连次数超过了最大重连次数阈值，则将重连次数重置为最小重连次数阈值
    if (server_list[serv_idx].reconnect_cnt > MAX_RECONNECT_CNT) {
        server_list[serv_idx].reconnect_cnt = MIN_RECONNECT_CNT;
    }
}

//从配置文件中读取服务器配置信息
serv_info_t* read_server_config(CConfigFileReader* config_file,
    const char* server_ip_format,
    const char* server_port_format,
    uint32_t& server_count);

#endif
```

### 用户令牌验证TokenValidator

```cpp
#ifndef TOKENVALIDATOR_H_
#define TOKENVALIDATOR_H_

#include "util.h"

/// @brief 生成令牌token
/// @param uid 用户id
/// @param time_offset 时间偏移量
/// @param md5_str_buf 指向字符数组的指针
/// @return 0 if generate token successful
int genToken(unsigned int uid, time_t time_offset, char* md5_str_buf);

/// @brief 验证用户令牌token是否有效
/// @param user_id 用户id
/// @param token 
/// @return 
bool IsTokenValid(uint32_t user_id, const char* token);

#endif
```

```cpp
#include "TokenValidator.h"

// 字符串常量，用作令牌生成过程中的密钥
#define AUTH_ENCRYPT_KEY "Mgj!@#123" 

// Constants are the integer part of the sines of integers (in radians) * 2^32.
// 定义 k[64] 和 r[] 用于MD5哈希计算的常量
const uint32_t k[64] = {
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
};

// r specifies the per-round shift amounts
const uint32_t r[] = { 
    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
};


/**
 * leftrotate function definition 用于左循环移位操作 
 * 接受两个参数 x 和 c，并返回将 x 向左循环移位 c 位后的结果
 * 
 * 宏定义展开后的表达式为 (((x) << (c)) | ((x) >> (32 - (c))))
 *  - (x) << (c) 表示将 x 向左移动 c 位，空出的低位用零填充
 *  - (x) >> (32 - (c)) 表示将 x 向右移动 32 - c 位，空出的高位用零填充
 *  - | 表示按位或操作，将左移和右移的结果合并起来
 * 这样宏定义 LEFTROTATE(x, c) 实现了将 x 向左循环移位 c 位的操作，保留了移位后的结果
 * 在一些位操作中，左循环移位常用于循环算法和加密算法的实现中
*/
#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))


/// @brief 将一个 uint32_t 类型的整数值转换为字节数组
/// @param val 要转换的uint32_t类型的整数值
/// @param bytes 指向uint8_t类型的字节数组的指针
void to_bytes(uint32_t val, uint8_t* bytes) {
    //将val的低字节存储在bytes[0]中
    bytes[0] = (uint8_t)val;
    //次低字节存储在bytes[1]中 依此类推
    bytes[1] = (uint8_t)(val >> 8);
    bytes[2] = (uint8_t)(val >> 16);
    bytes[3] = (uint8_t)(val >> 24);
    //通过右移操作val >> 8、val >> 16 和 val >> 24
    //将val中的高位逐步移动到低位，并将其强制转换为 uint8_t 类型后存储在相应的字节位置上
    //val >> 8 用于将变量val的二进制表示向右移动8位
}

/// @brief 将长度为4字节的字节数组转换为一个 uint32_t 类型的整数
/// @param bytes 指向字节数组的指针
/// @return uint32_t
uint32_t to_int32(const uint8_t* bytes) {
    /**
     * 函数中的每一行代码都将字节数组中的一个字节转换为 uint32_t 类型
     * 并根据其位置进行位移操作
     * 然后将这些结果通过 按位或运算符 | 进行合并
     * 得到最终的 uint32_t 值
    */
    return (uint32_t)bytes[0]
        | ((uint32_t)bytes[1] << 8)
        | ((uint32_t)bytes[2] << 16)
        | ((uint32_t)bytes[3] << 24);
}


/// @brief C实现的MD5哈希算法
/// @param initial_msg 初始消息
/// @param initial_len 消息的长度
/// @param digest 缓冲区用于存储生成的MD5哈希值
void md5(const uint8_t* initial_msg, size_t initial_len, uint8_t* digest) {
    // These vars will contain the hash
    uint32_t h0, h1, h2, h3;

    // Message (to prepare)
    uint8_t* msg = NULL;

    size_t new_len, offset;
    uint32_t w[16];
    uint32_t a, b, c, d, i, f, g, temp;

    // 1.使用预定义的常量初始化哈希变量 h0、h1、h2 和 h3
    // Initialize variables - simple count in nibbles:
    h0 = 0x67452301;
    h1 = 0xefcdab89;
    h2 = 0x98badcfe;
    h3 = 0x10325476;

    // 2.预处理消息
    // Pre-processing:
    // append "1" bit to message
    // append "0" bits until message length in bits ≡ 448 (mod 512)
    // append length mod (2^64) to message
    // 2-1.计算填充位后的消息长度
    for (new_len = initial_len + 1; new_len % (512 / 8) != 448 / 8; new_len++);

    // 2-2.分配内存以存储填充后的消息
    msg = (uint8_t*)malloc(new_len + 8);

    // 2-3.将初始消息复制到填充后的消息
    memcpy(msg, initial_msg, initial_len);

    // 2-4.在消息末尾追加 "1" 比特和零比特，直到长度满足模 512 余 448 的条件
    msg[initial_len] = 0x80; // append the "1" bit; most significant bit is "first"

    // 2-5.将填充后的消息的剩余部分设置为零比特0 这样做是为了确保消息的长度满足模 512 余 448 的条件
    for (offset = initial_len + 1; offset < new_len; offset++) msg[offset] = 0; // append "0" bits

    // 2-6.在消息末尾追加初始消息的比特长度
    // append the len in bits at the end of the buffer.
    to_bytes(initial_len * 8, msg + new_len);
    // initial_len>>29 == initial_len*8>>32, but avoids overflow.
    to_bytes(initial_len >> 29, msg + new_len + 4);

    // 3.照 512 比特块对消息进行处理
    // Process the message in successive 512-bit chunks:
    // for each 512-bit chunk of message:
    for (offset = 0; offset < new_len; offset += (512 / 8)) {
        // 3-1.将每个块分解为十六个 32 比特的单词（w[j]）
        for (i = 0; i < 16; i++) w[i] = to_int32(msg + offset + i * 4);

        // 3-2.使用哈希值初始化临时变量 a、b、c 和 d
        a = h0;
        b = h1;
        c = h2;
        d = h3;

        // 3-3.根据当前迭代进行一系列位操作和变换，更新 a、b、c 和 d
        for (i = 0; i < 64; i++) {
            if (i < 16) {
                f = (b & c) | ((~b) & d);
                g = i;
            } else if (i < 32) {
                f = (d & b) | ((~d) & c);
                g = (5 * i + 1) % 16;
            } else if (i < 48) {
                f = b ^ c ^ d;
                g = (3 * i + 5) % 16;
            } else {
                f = c ^ (b | (~d));
                g = (7 * i) % 16;
            }
            temp = d;
            d = c;
            c = b;
            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);//左循环位移进行加密
            a = temp;
        }

        // 4.将当前块的哈希值添加到当前结果中，更新哈希变量 h0、h1、h2 和 h3
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
    }

    // 5.清理用于填充后的消息的内存
    free(msg);

    // 6.使用 to_bytes 函数将生成的哈希值转换为字节，并将其存储在 digest 缓冲区中
    to_bytes(h0, digest);
    to_bytes(h1, digest + 4);
    to_bytes(h2, digest + 8);
    to_bytes(h3, digest + 12);
}


/// @brief 用于生成令牌token
/// 使用 MD5 哈希算法来计算字符串的MD5值，并将结果以字符串的形式存储在 md5_str_buf 中
/// @param uid 用户id
/// @param time_offset 时间偏移量
/// @param md5_str_buf 指向字符数组的指针
/// @return 0 if generate token successful
int genToken(unsigned int uid, time_t time_offset, char* md5_str_buf) {
    // MD5_CTX ctx;
    // 1.定义了一些临时缓冲区和变量，包括 tmp_buf、t_buf 和 md5_buf
    char tmp_buf[256];
    char t_buf[128];
    unsigned char md5_buf[32];

    // 2.通过调用系统相关的函数获取当前时间，并将其格式化为字符串存储在t_buf中
#ifdef _WIN32
    SYSTEMTIME systemTime;
    GetLocalTime(&systemTime);
    snprintf(t_buf, sizeof(t_buf), "%04d-%02d-%02d-%02d", systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour);
#else
    struct tm* tm;
    time_t currTime;
    time(&currTime);
    currTime += time_offset;
    tm = localtime(&currTime);
    snprintf(t_buf, sizeof(t_buf), "%04d-%02d-%02d-%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour);
#endif

    // 3.使用 snprintf 函数将字符串 tmp_buf 格式化为 %s_%u_%s_%s 的形式
    // AUTH_ENCRYPT_KEY预定义的密钥 uid用户id 混合
    snprintf(tmp_buf, sizeof(tmp_buf), "%s_%u_%s_%s", AUTH_ENCRYPT_KEY, uid, t_buf, AUTH_ENCRYPT_KEY);

    // 4.将 tmp_buf 的内容作为输入进行 MD5 计算，将结果存储在 md5_buf 中
    md5((unsigned char*)tmp_buf, strlen(tmp_buf), md5_buf);

    // 5.使用循环将 md5_buf 的每个字节转换为两位的十六进制字符串，并存储在 md5_str_buf 中
    for (int i = 0; i < 16; i++) sprintf(md5_str_buf + 2 * i, "%02x", md5_buf[i]);

    // 6.反转 md5_str_buf 的内容，将首尾的字符依次交换位置
    char c = 0;
    for (int i = 0; i < 16; i++) {
        c = md5_str_buf[i];
        md5_str_buf[i] = md5_str_buf[31 - i];
        md5_str_buf[31 - i] = c;
    }

    // 7.交换 md5_str_buf 中每两个连续字符的位置
    // switch md5_str_buf[i] and md5_str_buf[i + 1]
    for (int i = 0; i < 32; i += 2) {
        c = md5_str_buf[i];
        md5_str_buf[i] = md5_str_buf[i + 1];
        md5_str_buf[i + 1] = c;
    }
    return 0;
}


/// @brief 验证用户令牌token是否有效
/// @param user_id 用户id
/// @param token 
/// @return 
bool IsTokenValid(uint32_t user_id, const char* token) {
    // 1.定义了三个临时缓冲区用于存储生成的令牌
    char token1[64], token2[64], token3[64];

    // 2.调用 genToken 函数生成了三个令牌，分别对应用户id在过去一小时、当前时间和未来一小时的情况下生成的令牌
    genToken(user_id, -3600, token1); // token an hour ago
    genToken(user_id, 0, token2); // current token
    genToken(user_id, 3600, token3); // token an hour later

    // 3.如果传入的令牌与任何一个生成的令牌相等，则返回true表示令牌有效
    if (!strcmp(token, token1) || !strcmp(token, token2) || !strcmp(token, token3)) return true;
    return false;
}
```



### 功能定义public_define

```cpp
enum
{
    USER_CNT_INC = 1,
    USER_CNT_DEC = 2,
};

enum
{
    IM_GROUP_SETTING_PUSH = 1,
};

enum
{
    IM_PUSH_TYPE_NORMAL = 1,
    IM_PUSH_TYPE_SILENT = 2,
};

enum
{
    IM_PC_LOGIN_STATUS_ON = 1,
    IM_PC_LOGIN_STATUS_OFF = 0,
};
```

```cpp
typedef struct AudioMsgInfo{
    uint32_t    audioId;
    uint32_t    fileSize;
    uint32_t    data_len;
    uchar_t*    data;
    std::string path;
} AudioMsgInfo_t;

// 用户基本信息
typedef struct DBUserInfo_t {
    uint32_t        nId;        // 用户ID
    uint8_t         nSex;       // 用户性别 1.男;2.女
    uint8_t         nStatus;    // 用户状态0 正常， 1 离职
    uint32_t        nDeptId;    // 所属部门
    std::string     strNick;    // 花名
    std::string     strDomain;  // 花名拼音
    std::string     strName;    // 真名
    std::string     strTel;     // 手机号码
    std::string     strEmail;   // Email
    std::string     strAvatar;  // 头像
    std::string     sign_info;  // 个性签名
    
    DBUserInfo_t& operator=(const DBUserInfo_t& rhs) {
        /* 避免自我赋值 */
        if(this != &rhs) {
            nId = rhs.nId;
            nSex = rhs.nSex;
            nStatus = rhs.nStatus;
            nDeptId = rhs.nDeptId;
            strNick = rhs.strNick;
            strDomain = rhs.strDomain;
            strName = rhs.strName;
            strTel = rhs.strTel;
            strEmail = rhs.strEmail;
            strAvatar = rhs.strAvatar;
            sign_info = rhs.sign_info;
        }
        return *this;
    }
} DBUserInfo_t;
typedef std::unordered_map<uint32_t, DBUserInfo_t*> DBUserMap_t;

// 部门基本信息
typedef struct DBDeptInfo_t {
    uint32_t    nId;
    uint32_t    nParentId;
    std::string strName;
    
    DBDeptInfo_t& operator=(const DBDeptInfo_t& rhs) {
        /* 避免自我赋值 */
        if(this != &rhs) {
            nId = rhs.nId;
            nParentId = rhs.nParentId;
            strName = rhs.strName;
        }
        return *this;
    }
    
} DBDeptInfo_t;
typedef std::unordered_map<uint32_t, DBDeptInfo_t*> DBDeptMap_t;

// 用户连接信息
// 方便地记录用户的连接情况，并对连接数量进行统计和处理
typedef struct {
    uint32_t 	user_id;    //用户id
    uint32_t	conn_cnt;   //连接数量
} user_conn_t;

// 用户状态信息
typedef struct {
    uint32_t user_id;       //用户ID
    uint32_t status;        //用户状态
    uint32_t client_type;   //登录终端类型
} user_stat_t;

// 授权信息
// 通过使用 auth_struct 结构体，可以方便地记录和管理授权信息
// 例如确定用户是否有权限访问某些资源、验证用户的身份等
typedef struct {
    uint32_t                user_id;            //用户id
    std::set<uint32_t>      allow_user_ids;     //允许访问的用户id集合
    std::set<uint32_t>      allow_group_ids;    //允许访问的用户组id集合
    std::set<std::string>   authed_ips;         //已授权的IP地址集合
    std::set<std::string>   authed_interfaces;  //已授权的接口名称集合
} auth_struct;
```









































