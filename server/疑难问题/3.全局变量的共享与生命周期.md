# 全局变量的共享与生命周期

---

### 应用场景

### BaseSocket.h

网络库封装过程中，针对多个socket连接将其IO操作抽象为BaseSocket类，多个socket连接对应多个BaseSocket对象，

```cpp
enum
{
	SOCKET_STATE_IDLE,
	SOCKET_STATE_LISTENING,
	SOCKET_STATE_CONNECTING,
	SOCKET_STATE_CONNECTED,
	SOCKET_STATE_CLOSING
};

class CBaseSocket : public CRefObject
{
public:
	CBaseSocket();
	virtual ~CBaseSocket();

	SOCKET GetSocket() { return m_socket; }
	void SetSocket(SOCKET fd) { m_socket = fd; }
	void SetState(uint8_t state) { m_state = state; }

	void SetCallback(callback_t callback) { m_callback = callback; }
	void SetCallbackData(void* data) { m_callback_data = data; }
	void SetRemoteIP(char* ip) { m_remote_ip = ip; }
	void SetRemotePort(uint16_t port) { m_remote_port = port; }
	void SetSendBufSize(uint32_t send_size);
	void SetRecvBufSize(uint32_t recv_size);

	const char*	GetRemoteIP() { return m_remote_ip.c_str(); }
	uint16_t	GetRemotePort() { return m_remote_port; }
	const char*	GetLocalIP() { return m_local_ip.c_str(); }
	uint16_t	GetLocalPort() { return m_local_port; }

public:
	// 监听连接/服务器
	int Listen(
		const char*		server_ip, 
		uint16_t		port,
		callback_t		callback,
		void*			callback_data);
	
	// 发起连接/客户端
	net_handle_t Connect(
		const char*		server_ip, 
		uint16_t		port,
		callback_t		callback,
		void*			callback_data);

	int Send(void* buf, int len);
	int Recv(void* buf, int len);
	int Close();
	
	void OnRead();
	void OnWrite();
	void OnClose();

private:
	int _GetErrorCode();
	bool _IsBlock(int error_code);

	void _SetNonblock(SOCKET fd);
	void _SetReuseAddr(SOCKET fd);
	void _SetNoDelay(SOCKET fd);
	void _SetAddr(const char* ip, const uint16_t port, sockaddr_in* pAddr);
	
	void _AcceptNewSocket();
private:
	std::string		m_remote_ip;		//远程IP地址
	uint16_t		m_remote_port;		//远程端口号
	std::string		m_local_ip;			//本地IP地址
	uint16_t		m_local_port;		//本地端口号

	callback_t		m_callback;			//回调函数(用于处理套接字事件)
	void*			m_callback_data;	//回调函数参数

	uint8_t			m_state;			//套接字的状态
	SOCKET			m_socket;			//套接字描述符
};

CBaseSocket* FindBaseSocket(net_handle_t fd);
```

### BaseSocket.cpp

但是对于basesocket对象的存储与管理，采用一个全局变量SocketMap g_socket_map;来处理：

```cpp
#include "BaseSocket.h"
#include "EventDispatch.h"
#include <unordered_map>

typedef unordered_map<net_handle_t, CBaseSocket*> SocketMap;
SocketMap g_socket_map;

void AddBaseSocket(CBaseSocket* pSocket)
{
    g_socket_map.insert(make_pair((net_handle_t)pSocket->GetSocket(), pSocket));
}

void RemoveBaseSocket(CBaseSocket* pSocket)
{
    g_socket_map.erase((net_handle_t)pSocket->GetSocket());
}

CBaseSocket* FindBaseSocket(net_handle_t fd)
{
    CBaseSocket* pSocket = NULL;
    SocketMap::iterator iter = g_socket_map.find(fd);
    if (iter != g_socket_map.end()) {
        pSocket = iter->second;
        pSocket->AddRef();
    }
    return pSocket;
}
```

### 全局变量的共享与生命周期

此时针对于多个BaseSocket对象的数据共享与全局变量的初始化、与生命周期出现了疑问？

`g_socket_map` 是一个静态存储区的全局变量，生命周期是整个程序运行期，所有CBaseSocket对象共享同一个实例。

#### 数据共享

全局变量`g_socket_map`的性质，在BaseSocket.cpp中无论创建了多少个CBaseSocket对象，g_socket_map 始终是同一个全局实例。

所有 `CBaseSocket` 对象共享同个 `g_socket_map`。

#### 生命周期

1. 初始化时机：

   - g_socket_map 在程序启动时、main函数执行前初始化
   - 在静态存储区分配内存并调用构造函数

2. 释放时机：

   - 在程序退出时、main函数结束后释放
   - 析构顺序与构造顺序相反（在静态销毁阶段）

3. 完整生命周期：

   ```
   程序启动
       ↓
   静态变量初始化（g_socket_map构造）
       ↓  
   main() 函数执行
       ↓
   创建CBaseSocket对象 → 添加到g_socket_map
       ↓
   使用socket...
       ↓  
   main() 函数结束
       ↓
   静态变量析构（g_socket_map析构，调用~unordered_map()）
       ↓
   程序退出
   ```

### 全局变量与静态变量

```
┌─────────────────────┐
│     栈区 (Stack)     │ ← 局部变量、函数参数
├─────────────────────┤
│          ↓          │
├─────────────────────┤
│          ↑          │
├─────────────────────┤
│      堆区 (Heap)     │ ← malloc/new 动态分配
├─────────────────────┤
│    BSS段 (未初始化数据) │ ← 未初始化的全局/静态变量
├─────────────────────┤
│   Data段 (已初始化数据) │ ← 已初始化的全局/静态变量
├─────────────────────┤
│    代码段 (Text)      │ ← 程序代码
└─────────────────────┘
```

| 变量类型     | 存储区域   | 作用域     | 链接性   | 生命周期   |
| ------------ | ---------- | ---------- | -------- | ---------- |
| 全局变量     | 静态存储区 | 文件内     | 外部链接 | 程序运行期 |
| 静态全局变量 | 静态存储区 | 文件内     | 内部链接 | 程序运行期 |
| 静态局部变量 | 静态存储区 | 函数内     | 无链接   | 程序运行期 |
| 静态成员变量 | 静态存储区 | 类作用域   | 根据声明 | 程序运行期 |
| 局部变量     | 栈区       | 函数内     | 无链接   | 函数执行期 |
| 动态分配变量 | 堆区       | 由指针决定 | 无链接   | 直到delete |













