# 消息发送全流程

---

### 1.消息发送全流程

CID_MSG_DATA

客户端接受到的消息是根据消息id进行排序的，而不是根据消息发送的时间，

![image-20230522154744937](assets/image-20230522154744937.png)

msg_server与数据库通信：

1. 将数据发送给数据库，如果是第一次会话需要创建会话（将会话信息写入数据库中），如果已经有会话关系直接获取即可
2. 将消息发送写入到数据库中，进行一定的处理（添加消息msgId），将消息发回到msg_server中（带上消息msgId），在协议header中有一个seq_id
3. msg_server转发消息，如果客户端在线，将消息直接发送给客户端，如果客户端不在线，将消息存储到离线消息数据库中，当下一次客户端上线，将离线消息读取后发送给客户端（并将数据库中的离线消息标记为已读），
   - 先在msg_server中查询对端的user_id，
   - 广播到route_server服务器中（发送给1个route_server就可以了），在route_server根据对端user_id找到是在哪个msg_server中


![image-20230522230334036](assets/image-20230522230334036.png)

```cpp
//service id  0x0003
message IMMsgData{
	//cmd id:		0x0301
	required uint32 from_user_id = 1;				//消息发送方
	required uint32 to_session_id = 2;				//消息接受方
	required uint32 msg_id = 3;
	required uint32 create_time = 4; 
	required IM.BaseDefine.MsgType msg_type = 5;
	required bytes msg_data = 6;
	optional bytes attach_data = 20;
}
```

```cpp
message IMMsgDataAck{
	//cmd id:		0x0302
	required uint32 user_id = 1;			//发送此信令的用户id
	required uint32 session_id = 2;				
	required uint32 msg_id = 3;
	required IM.BaseDefine.SessionType session_type = 4;
}
```

```cpp
message IMMsgDataReadAck{
	//cmd id:		0x0303
	required uint32 user_id = 1;			//发送此信令的用户id
	required uint32 session_id = 2;			
	required uint32 msg_id = 3;
	required IM.BaseDefine.SessionType session_type = 4;
}
```

```cpp
message IMMsgDataReadNotify{
	//cmd id:		0x0304
	required uint32 user_id = 1;			//发送此信令的用户id
	required uint32 session_id = 2;		
	required uint32 msg_id = 3;
	required IM.BaseDefine.SessionType session_type = 4;
}
```

每个CImUser对应⼀个登陆⽤户，CMsgConn对应⼀个端的登录，CImUser和CMsgConn是1:n的对应关系。

1. CMsgConn::HandlePdu （msg_server模块，处理客户端的请求的信息）
2. CMsgConn::_HandleClientMsgData（msg_server模块，处理客户端的消息发送，CID_MSG_DATA命令）,重新拼装pdu，主要是增加handle作为attach数据，然后发送给db_proxy_server
3. DB_PROXY::sendMessage （db_proxy_server模块），
   - 获取消息FromId，ToId, MsgType等，并先验证消息类型MsgType是否有效 （这⾥主要先分析单聊的情况）
   - nSessionId 服务器分配会话id：通过CSessionModel::getSessionId查询两个⼈直接的聊天是否已经建⽴最近会话记录(从IMRecentSession表)，如果没有记录则调⽤CSessionModel::addSession创建
   - nPeerSessionId 服务器分配对端会话id：通过CSessionModel::getSessionId查询两个⼈直接的聊天是否已经建⽴最近会话记录(从IMRecentSession表)，如果没有记录则调⽤CSessionModel::addSession创建，需要注意的是nPeerSessionId和nSessionId的FromId和ToId是相反的。
   - nRelateId：获取通话⼈之间的关系id，如果两者之前没有关系则调⽤CRelationModel::getRelationId进⾏添加（操作IMRelationShip表）
   - nMsgId 服务器分配消息id，CMessageModel::getMsgId根据nRelateId映射进⾏获取，（FromId和ToId相互之间的nRelateId是唯⼀的，不分⽅向性，进⽽保证相互之间发送消息时消息的顺序性），msgId存储在redis中，通过key为"msg_id_" + int2string(nRelateId)进⾏获取，每次进⾏+1的递增操作
   - CMessageModel::sendMessage 将消息插⼊到数据库（操作IMMessage_x表），发送消息和要读取消息之间存储的是同⼀条消息：nRelateId, nFromId, nToId, nMsgType, nCreateTime,nMsgId，msg_data
   - 然后封装响应pPduResp，最重要的是附带nMsgId和msg回发给msg_server，使⽤CID_MSG_DATA命令。⼀样是以AddResponsePdu插⼊队列，然后SendResponsePduList进⾏回发的套路。
4. CDBServConn::HandlePdu （msg_server模块，处理dbproxy回发的数据），根据CID_MSG_DATA找到对应的处理函数
5. CDBServConn::_HandleMsgData（msg_server模块）
   - 根据attach_data的handle查找到对应的socket通路，使⽤CID_MSG_DATA_ACK告知客户端消息已经发送到服务器。
   - get_route_serv_conn，将pdu发送给route_server， CRouteConn::HandlePdu进⾏响应，然后调⽤CRouteConn::_BroadcastMsg转发给其他msg_server。
   - CImUser::BroadcastClientMsgData：⼴播给消息发起者，对于发起者不需要⼴播给⾃⼰的，只需要⼴播给其他端（⽐如多端登录时，PC端发送的数据，则⼴播给Android、IOS端，不⽤再⼴播给PC端），并将该消息插⼊到m_send_msg_list。
   - CImUser::BroadcastClientMsgData：⼴播给消息接收者，有⼏端登录同⼀个账号就⼴播给⼏个端，并将该消息插⼊到m_send_msg_list
   - CID_OTHER_GET_DEVICE_TOKEN_REQ：消息推送请求，主要是针对Android和IOS，此时由从新发回给db_proxy_server， 在setDevicesToken进⾏响应，我们这⾥不继续关注它。
6. 接收的客户端写⼊消息的回应
7. 作为接收者的客户端读取消息后回应CMsgConn::_HandleClientMsgReadAck（msg_server模块），使⽤CID_MSG_READ_ACK命令。
   - 使⽤CID_MSG_READ_NOTIFY通知其他多端登录的客户端，已经有客户端读取了该消息。
   - 将该msg从m_send_msg_list移除。
   - 如果客户端没有回应，则CMsgConn::OnTimer定时器定时check消息是否已经正常发送给客户端，没有收到响应则认为g_down_msg_miss_cnt++，该详细下⾏失败。











### 2.聊天逻辑流程DBP

```cpp
//service id  0x0003
message IMMsgData{
	//cmd id:		0x0301
	required uint32 from_user_id = 1;				//消息发送方
	required uint32 to_session_id = 2;				//消息接受方
	required uint32 msg_id = 3;
	required uint32 create_time = 4; 
	required IM.BaseDefine.MsgType msg_type = 5;
	required bytes msg_data = 6;
	optional bytes attach_data = 20;
}
```

#### MessageContent.cpp->sendMessage

```cpp
void sendMessage(CImPdu* pPdu, uint32_t conn_uuid) {
  //pDu数据解析
  IM::Message::IMMsgData msg;
  if (msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
    uint32_t nFromId = msg.from_user_id();
    uint32_t nToId = msg.to_session_id();
    uint32_t nCreateTime = msg.create_time();
    IM::BaseDefine::MsgType nMsgType = msg.msg_type();//消息类型
    uint32_t nMsgLen = msg.msg_data().length();

    uint32_t nNow = (uint32_t)time(NULL);

    //开始对消息进行处理
    if (IM::BaseDefine::MsgType_IsValid(nMsgType)) {
      if (nMsgLen != 0) {
        CImPdu* pPduResp = new CImPdu;

        uint32_t nMsgId = INVALID_VALUE;
        uint32_t nSessionId = INVALID_VALUE;
        uint32_t nPeerSessionId = INVALID_VALUE;

        CMessageModel* pMsgModel = CMessageModel::getInstance();
        CGroupMessageModel* pGroupMsgModel = CGroupMessageModel::getInstance();

        //1.群聊文本消息
        if (nMsgType == IM::BaseDefine::MSG_TYPE_GROUP_TEXT) {
          CGroupModel* pGroupModel = CGroupModel::getInstance();
          if (pGroupModel->isValidateGroupId(nToId) &&
              pGroupModel->isInGroup(nFromId, nToId)) {
            nSessionId = CSessionModel::getInstance()->getSessionId(
                nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(
                  nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP);
            }
            if (nSessionId != INVALID_VALUE) {
              nMsgId = pGroupMsgModel->getMsgId(nToId);
              if (nMsgId != INVALID_VALUE) {
                pGroupMsgModel->sendMessage(nFromId, nToId, nMsgType,
                                            nCreateTime, nMsgId,
                                            (string&)msg.msg_data());
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
              }
            }
          } else {
            log("invalid groupId. fromId=%u, groupId=%u", nFromId, nToId);
            delete pPduResp;
            return;
          }
        } else if (nMsgType == IM::BaseDefine::MSG_TYPE_GROUP_AUDIO) {
          //2.群聊语音消息
          CGroupModel* pGroupModel = CGroupModel::getInstance();
          if (pGroupModel->isValidateGroupId(nToId) &&
              pGroupModel->isInGroup(nFromId, nToId)) {
            nSessionId = CSessionModel::getInstance()->getSessionId(
                nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(
                  nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP);
            }
            if (nSessionId != INVALID_VALUE) {
              nMsgId = pGroupMsgModel->getMsgId(nToId);
              if (nMsgId != INVALID_VALUE) {
                pGroupMsgModel->sendAudioMessage(
                    nFromId, nToId, nMsgType, nCreateTime, nMsgId,
                    msg.msg_data().c_str(), nMsgLen);
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
              }
            }
          } else {
            log("invalid groupId. fromId=%u, groupId=%u", nFromId, nToId);
            delete pPduResp;
            return;
          }
        } else if (nMsgType == IM::BaseDefine::MSG_TYPE_SINGLE_TEXT) {
          //3.单聊文本消息
          if (nFromId != nToId) {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);//自己的sessionId
            if (INVALID_VALUE == nSessionId) nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE);
            
            nPeerSessionId = CSessionModel::getInstance()->getSessionId(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);//对端的sessionId
            if (INVALID_VALUE == nPeerSessionId) nSessionId = CSessionModel::getInstance()->addSession(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE);

            uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nFromId, nToId, true);

            if (nSessionId != INVALID_VALUE && nRelateId != INVALID_VALUE) {
              nMsgId = pMsgModel->getMsgId(nRelateId);
              if (nMsgId != INVALID_VALUE) {
                pMsgModel->sendMessage(nRelateId, nFromId, nToId, nMsgType, nCreateTime, nMsgId, (string&)msg.msg_data());//将消息存入数据库中 并将消息计数+1
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);//更新会话比较耗时 对于即时通信的系统性能 受数据库处理的影响较大
                CSessionModel::getInstance()->updateSession(nPeerSessionId, nNow);
              } else {
                log("msgId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u",
                    nFromId, nToId, nRelateId, nSessionId, nMsgType);
              }
            } else {
              log("sessionId or relateId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u",
                  nFromId, nToId, nRelateId, nSessionId, nMsgType);
            }
          } else {
            log("send msg to self. fromId=%u, toId=%u, msgType=%u", nFromId,
                nToId, nMsgType);
          }

        } else if (nMsgType == IM::BaseDefine::MSG_TYPE_SINGLE_AUDIO) {
          //4.单聊语音消息
          if (nFromId != nToId) {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if (INVALID_VALUE == nSessionId) nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE);

            nPeerSessionId = CSessionModel::getInstance()->getSessionId(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if (INVALID_VALUE == nPeerSessionId) nSessionId = CSessionModel::getInstance()->addSession(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE);

            uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nFromId, nToId, true);

            if (nSessionId != INVALID_VALUE && nRelateId != INVALID_VALUE) {
              nMsgId = pMsgModel->getMsgId(nRelateId);
              if (nMsgId != INVALID_VALUE) {
                pMsgModel->sendAudioMessage(nRelateId, nFromId, nToId, nMsgType,
                                            nCreateTime, nMsgId,
                                            msg.msg_data().c_str(), nMsgLen);
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
                CSessionModel::getInstance()->updateSession(nPeerSessionId, nNow);
              } else {
                log("msgId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u",
                    nFromId, nToId, nRelateId, nSessionId, nMsgType);
              }
            } else {
              log("sessionId or relateId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u",
                  nFromId, nToId, nRelateId, nSessionId, nMsgType);
            }
          } else {
            log("send msg to self. fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
          }
        }

        log("fromId=%u, toId=%u, type=%u, msgId=%u, sessionId=%u", nFromId, nToId, nMsgType, nMsgId, nSessionId);

        msg.set_msg_id(nMsgId);
        pPduResp->SetPBMsg(&msg);
        pPduResp->SetSeqNum(pPdu->GetSeqNum());
        pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
        pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_DATA);
        CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
      } else {
        log("msgLen error. fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
      }
    } else {
      log("invalid msgType.fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
    }
  } else {
    log("parse pb failed");
  }
}
```

#### 单聊MessageModel.cpp->CMessageModel::sendMessage

用户选择单聊

![image-20230528095408535](assets/image-20230528095408535.png)

![image-20230528094928303](assets/image-20230528094928303.png)

```cpp
/*
 * IMMessage 分表
 * AddFriendShip()
 * if nFromId or nToId is ShopEmployee
 * GetShopId
 * Insert into IMMessage_ShopId%8
 */
bool CMessageModel::sendMessage(uint32_t nRelateId, uint32_t nFromId,
                                uint32_t nToId,
                                IM::BaseDefine::MsgType nMsgType,
                                uint32_t nCreateTime, uint32_t nMsgId,
                                string& strMsgContent) {
  bool bRet = false;
  if (nFromId == 0 || nToId == 0) {
    log("invalied userId.%u->%u", nFromId, nToId);
    return bRet;
  }

  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn) {
    //通过id映射到对应的数据库表
    string strTableName = "IMMes    sage_" + int2string(nRelateId % 8);
    string strSql =
        "insert into " + strTableName +
        " (`relateId`, `fromId`, `toId`, `msgId`, `content`, `status`, `type`, "
        "`created`, `updated`) values(?, ?, ?, ?, ?, ?, ?, ?, ?)";
    // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
    CPrepareStatement* pStmt = new CPrepareStatement();
    // 1.数据库写入
    if (pStmt->Init(pDBConn->GetMysql(), strSql)) {
      uint32_t nStatus = 0;
      uint32_t nType = nMsgType;
      uint32_t index = 0;
      pStmt->SetParam(index++, nRelateId);
      pStmt->SetParam(index++, nFromId);
      pStmt->SetParam(index++, nToId);
      pStmt->SetParam(index++, nMsgId);
      pStmt->SetParam(index++, strMsgContent);
      pStmt->SetParam(index++, nStatus);
      pStmt->SetParam(index++, nType);
      pStmt->SetParam(index++, nCreateTime);
      pStmt->SetParam(index++, nCreateTime);
      bRet = pStmt->ExecuteUpdate();
    }
    delete pStmt;
    // 2.释放掉连接
    pDBManager->RelDBConn(pDBConn);
    if (bRet) {
      uint32_t nNow = (uint32_t)time(NULL);
      incMsgCount(nFromId, nToId);//消息未读计数器更新
    } else {
      log("insert message failed: %s", strSql.c_str());
    }
  } else {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}
```



#### 群聊GroupMessageModel.cpp->CGroupMessageModel::sendMessage

用户选择群聊

![image-20230528150041410](assets/image-20230528150041410.png)

![image-20230528112434053](assets/image-20230528112434053.png)

```cpp
/**
 *  发送群消息接口
 *
 *  @param nRelateId     关系Id
 *  @param nFromId       发送者Id
 *  @param nGroupId      群组Id
 *  @param nMsgType      消息类型
 *  @param nCreateTime   消息创建时间
 *  @param nMsgId        消息Id
 *  @param strMsgContent 消息类容
 *
 *  @return 成功返回true 失败返回false
 */
bool CGroupMessageModel::sendMessage(uint32_t nFromId, uint32_t nGroupId,
                                     IM::BaseDefine::MsgType nMsgType,
                                     uint32_t nCreateTime, uint32_t nMsgId,
                                     const string& strMsgContent) {
  bool bRet = false;
  if (CGroupModel::getInstance()->isInGroup(nFromId, nGroupId)) {
    CDBManager* pDBManager = CDBManager::getInstance();
    //将消息写入mysql数据库中
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
    if (pDBConn) {
      //同一个群中的消息是在同一张数据库的表中
      //通过hash的方式将数据存储到不同的数据库表中
      string strTableName = "IMGroupMessage_" + int2string(nGroupId % 8);
      string strSql = "insert into " + strTableName +
                      " (`groupId`, `userId`, `msgId`, `content`, `type`, "
                      "`status`, `updated`, `created`) "
                      "values(?, ?, ?, ?, ?, ?, ?, ?)";
      
      //1.对数据库的操作
      // 必须在释放连接前delete
      // CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
      CPrepareStatement* pStmt = new CPrepareStatement();
      if (pStmt->Init(pDBConn->GetMysql(), strSql)) {
        uint32_t nStatus = 0;
        uint32_t nType = nMsgType;
        uint32_t index = 0;
        pStmt->SetParam(index++, nGroupId);
        pStmt->SetParam(index++, nFromId);
        pStmt->SetParam(index++, nMsgId);
        pStmt->SetParam(index++, strMsgContent);
        pStmt->SetParam(index++, nType);
        pStmt->SetParam(index++, nStatus);
        pStmt->SetParam(index++, nCreateTime);
        pStmt->SetParam(index++, nCreateTime);

        bool bRet = pStmt->ExecuteUpdate();
        if (bRet) {
          //更新updateGroupChat信息（set lastChated最后一条群消息时间）
          CGroupModel::getInstance()->updateGroupChat(nGroupId);
          incMessageCount(nFromId, nGroupId);//添加群消息总计数
          clearMessageCount(nFromId, nGroupId);//清除发送群消息的用户的未读消息计数
        } else {
          log("insert message failed: %s", strSql.c_str());
        }
      }
      delete pStmt;
      pDBManager->RelDBConn(pDBConn);
    } else {
      log("no db connection for teamtalk_master");
    }
  } else {
    log("not in the group.fromId=%u, groupId=%u", nFromId, nGroupId);
  }
  return bRet;
}
```

#### SyncCenter.cpp->CSyncCenter::doSyncGroupChat

```cpp
/**
 *  同步群组聊天信息
 *
 *  @param arg NULL
 *
 *  @return NULL
 */
void* CSyncCenter::doSyncGroupChat(void* arg) {
  m_bSyncGroupChatRuning = true;
  CDBManager* pDBManager = CDBManager::getInstance();
  map<uint32_t, uint32_t> mapChangedGroup;
  do {
    mapChangedGroup.clear();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if (pDBConn) {
      //1.检查群消息是否有更新
      string strSql =
          "select id, lastChated from IMGroup where status=0 and lastChated >=" +
          int2string(m_pInstance->getLastUpdateGroup());
      CResultSet* pResult = pDBConn->ExecuteQuery(strSql.c_str());
      //2.获取群聊消息最后更新的时间
      if (pResult) {
        while (pResult->Next()) {
          uint32_t nGroupId = pResult->GetInt("id");
          uint32_t nLastChat = pResult->GetInt("lastChated");
          if (nLastChat != 0) {
            mapChangedGroup[nGroupId] = nLastChat;//获取最后更新的时间
          }
        }
        delete pResult;
      }
      pDBManager->RelDBConn(pDBConn);
    } else {
      log("no db connection for teamtalk_slave");
    }
    //3.设置最后一次同步的时间 用来做下一次的对比
    m_pInstance->updateLastUpdateGroup(time(NULL));
    for (auto it = mapChangedGroup.begin(); it != mapChangedGroup.end(); ++it) {
      /* 遍历所有的群 进行处理 */
      uint32_t nGroupId = it->first;
      list<uint32_t> lsUsers;
      uint32_t nUpdate = it->second;//获取该群对应的最后更新时间
      //4.从redis中获取群成员（将群存入redis中提升访问速度）
      CGroupModel::getInstance()->getGroupUser(nGroupId, lsUsers);
      for (auto it1 = lsUsers.begin(); it1 != lsUsers.end(); ++it1) {
        uint32_t nUserId = *it1;
        uint32_t nSessionId = INVALID_VALUE;
        nSessionId = CSessionModel::getInstance()->getSessionId(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP, true);//获取sessionId
        if (nSessionId != INVALID_VALUE) {
          //将该群的最后更新时间 设置到sessionId对应的群聊中
          CSessionModel::getInstance()->updateSession(nSessionId, nUpdate);
        } else {
          CSessionModel::getInstance()->addSession(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP);
        }
      }
    }
  } while (m_pInstance->m_bSyncGroupChatWaitting && !(m_pInstance->m_pCondGroupChat->waitTime(5 * 1000)));//更新时间设置为5s
  //    } while (!m_pInstance->m_pCondSync->waitTime(5*1000));
  //    } while(m_pInstance->m_bSyncGroupChatWaitting);
  m_bSyncGroupChatRuning = false;
  return NULL;
}
```

```cpp
/* SyncCenter.cpp */
/**
 *  停止同步，为了"优雅"的同步，使用了条件变量
 */
void CSyncCenter::stopSync() {
  m_bSyncGroupChatWaitting = false;
  m_pCondGroupChat->notify();
  while (m_bSyncGroupChatRuning) {
    usleep(500);
  }
}
```



### 3.群消息转发MS

1. CID_GROUP_INFO_REQUEST
2. void getGroupInfo(CImPdu *pPdu, unit32_t conn_uuid)
3. case CID_GROUP_INFO_RESPONSE
4. HandleGroupInfoResponse发送数据

![image-20230528183655519](assets/image-20230528183655519.png)

![image-20230528183645688](assets/image-20230528183645688.png)

#### DBServConn.cpp->CDBServConn::_HandleMsgData

```cpp

```



#### GroupChat.cpp->CGroupChat::HandleGroupMessage

```cpp

```









