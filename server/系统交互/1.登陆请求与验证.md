# 登陆请求与验证

---

### 登录流程-客户端

#### 1.获取消息服务器地址http

##### 请求

```json
http://106.75.230.157:8080/msg_server
```

```http
GET /msg_server HTTP/1.1
Host: 106.75.230.157:8080
Connection: keep-alive
Accept: */*;
```

##### 响应

```json
HTTP/1.1 200 OK
Connection:close
Content-Length:273
Content-Type:text/html;charset=utf-8
{
   "code" : 0,
   "priorIP" : "106.75.230.157",
   "backupIP" : "106.75.230.157",
   "port" : "8000",
   "msfsPrior" : "http://106.75.230.157:8700/",
   "msfsBackup" : "http://106.75.230.157:8700/",
   "msg" : "",
   "discovery" : "http://106.75.230.157/api/discovery"
}
```

1. LoginDialog::_DoLogin：用户点击登录按钮触发：`LoginDialog::_DoLogin`方法，将http登录请求操作添加到 http线程池中处理，进行登录操作。
2. 异步登录请求与处理
   - http线程池中发起请求 `DoLoginServerHttpOperation::processOpertion` ，返回请求结果。
   - 根据登录请求结果，调用回调函数进行进一步处理 `OnHttpCallbackOperation` 
3. 如果http请求失败：显示获取消息服务器地址失败
4. 如果http请求成功：通过tcp协议尝试连接登录到消息服务器上

#### 2.客户端连接到消息服务器tcp

1. 逻辑任务队列线程，调用 `module::getTcpClientModule()->doLogin()` 方法尝试连接到消息服务器上，

   建立socket连接发送数据包：

   ```
   service_id = SID_LOGIN
   command_id = CID_LOGIN_REQ_USERLOGIN
   seq_num = 包序列号
   length = 数据包长度
   ```

2. tcp登录请求失败：向ui代理窗口线程中发送异步消息

3. tcp登录成功：

   - 创建本地用户文件夹，
   - 再向ui代理窗口线程中发送异步消息，通知代理窗口线程调用OnPoerationCallback(),进行登录成功和登录失败的一系列处理
   - 开始与消息服务器发送心跳包，调用方法 `module::getTcpClientModule()->startHeartbeat()` 

### 登录流程-服务端

1. 登录服务端netlib_listen(cal, cal_data)设置回调函数m_calback
2. 初始化该socket并设置状态为SOCKET_STATE_LISTENING
3. 当有客户端连接时，CBaseSocket::OnRead()中检测到该socket状态为监听状态，则调用_AcceptNewSocket()，否则调用m_callback()
4. 对于处于监听状态的socket，将 接受的新连接置于已连接状态，并加入到全局map中管理，并将新的socket加入事件分发器中监听读事件，且调用之前设置的回调函数m_callback()
5. m_callback()调用CHttpConn::OnConnect(handle)，新建CHttpConn连接实例，加入到全局conn_map中管理，并设置会话类回调httpConn_callback()
6. 对于已连接状态的socket，调用建立连接时设置的回调函数httpConn_callback()
7. 调用会话类中的读写反应函数
8. CHttpConn::OnRead()是请求msg服务器ip，则调用_HandleMsgServRequest，将msg服务器ip信息，封装成json格式数据发送出去，数据不能发送出去先放缓冲区，发送完成调用OnWriteComlete（），进行关闭http连接
9. 客户端获取到msg信息后，发送登录包给msg
10. msg处理链接流程与上同，在处理消息时，先解析，再与数据库做比对，再回应客户端



### 登录请求与验证

1. 客户端通过发送http请求给login_server，查找哪一个msg_server负载最少
2. login_server通过json的方式返回msg_server的服务器地址ip+port，发送回给客户端，
3. 客户端拿到msg_server的服务器地址ip+port发送登录请求，发送`CID_LOGIN_REQ_MSGSERVER`

![image-20230518130437735](assets/image-20230518130437735.png)

CID_LOGIN_REQ_USERLOGIN

结合proto文件理解msg_server登录逻辑，

![image-20230520184623261](assets/image-20230520184623261.png)

```cpp
/* IM.Login.proto */
message IMLoginReq{
	//cmd id:		0x0103
	required string user_name = 1;
	required string password = 2;
	required IM.BaseDefine.UserStatType online_status = 3;
	required IM.BaseDefine.ClientType client_type = 4;
	optional string client_version = 5;
}
message IMLoginRes{
	//cmd id:		0x0104
	required uint32 server_time = 1;
	required IM.BaseDefine.ResultType result_code = 2;
	optional string result_string = 3;
	optional IM.BaseDefine.UserStatType online_status = 4;
	optional IM.BaseDefine.UserInfo user_info = 5;
}
```

1. CMsgConn::HandlePdu （msg_server模块，处理客户端的请求的信息）
2. CMsgConn::_HandleLoginRequest （msg_server模块，处理客户端的登录请求信息，CID_LOGIN_REQ_USERLOGIN命令）
3. CImUserManager::AddImUserByLoginName（msg_server模块，将登录的user_name封装以user_name(login_name)为key封装成pImUser插⼊到m_im_user_map_by_name）
4. proxy_serv_callback （db_proxy_server模块）处理其他server的数据库操作请求，每个请求new CProxyConn()；
5. DB_PROXY::doLogin （db_proxy_server模块）msg_server 往dbproxy_server发登录验证请求（CID_OTHER_VALIDATE_REQ），在db_proxy_server的doLogin进⾏处理，主要流程：
   - 先检测是否密码经常错误
   - 调⽤CInterLoginStrategy::doLogin 验证账号和密码是否匹配
   - 如果账号密码匹配则返回正确，如果错误则返回错误，使⽤CID_OTHER_VALIDATE_RSP命令；
6. CProxyConn::AddResponsePdu （db_proxy_server模块）处理完其他server的请求后需要回发信息，但不会直接调⽤send进⾏发送，⽽是封装成ResponsePdu_t插⼊到s_response_pdu_list队列，由另外的线程取出来进⾏发送。
7. CProxyConn::SendResponsePduList（db_proxy_server模块）负责回发 ResponsePdu_t。打个断点也⽅便分析是loop循环由谁发起，实际上这⾥的loop和epoll所在的loop同属于⼀个⼤loop。init_proxy_conn时调⽤netlib_add_loop(proxy_loop_callback, NULL);进⾏注册loop，⽽proxy_loop_callback实质是调⽤了CProxyConn::SendResponsePduList()
8. CDBServConn::HandlePdu （msg_server模块，处理dbproxy回发的数据），根据CID_OTHER_VALIDATE_RSP找到对应的处理函数
9. CDBServConn::_HandleValidateResponse （msg_server模块），使⽤CID_LOGIN_RES_USERLOGIN命令回应客户端。
10. CRouteServConn::_HandlePCLoginStatusNotify（msg_server模块）客户端回复CID_OTHER_LOGIN_STATUS_NOTIFY，通知其他端⽬前⾃⼰的登录情况。

##### MsgConn.h->CMsgConn::HandlePdu

![image-20230520185131990](assets/image-20230520185131990.png)

```cpp
//处理收到的PDU 根据PDU的命令ID，将其分派给相应的处理函数
void CMsgConn::HandlePdu(CImPdu* pPdu)
{   
    // 1.检查pPdu的命令ID是否为CID_OTHER_HEARTBEAT（心跳命令）如果不是心跳命令，则打印相应的日志信息
    if (pPdu->GetCommandId() != CID_OTHER_HEARTBEAT)
        log("HandlePdu cmd:0x%04x\n", pPdu->GetCommandId()); // request authorization check
    // 2.检查pPdu的命令ID是否为CID_LOGIN_REQ_USERLOGIN（用户登录请求）并且当前连接是打开的并且被踢出的状态
    if (pPdu->GetCommandId() != CID_LOGIN_REQ_USERLOGIN && !IsOpen() && IsKickOff()) {
        //如果条件满足则打印相应的日志信息，并抛出一个CPduException异常，异常信息指示处理PDU时出错用户未登录
        log("HandlePdu, wrong msg. ");
        throw CPduException(pPdu->GetServiceId(), pPdu->GetCommandId(), ERROR_CODE_WRONG_SERVICE_ID, "HandlePdu error, user not login. ");
        return;
    }
    // 3.最后通过switch语句根据pPdu的命令ID执行相应的操作
    // 根据不同的命令ID，调用相应的私有方法来处理不同的请求，例如处理心跳、用户登录请求、用户登出请求等
    switch (pPdu->GetCommandId()) {
    case CID_OTHER_HEARTBEAT:
        _HandleHeartBeat(pPdu);
        break;
    case CID_LOGIN_REQ_USERLOGIN:
        _HandleLoginRequest(pPdu);
        break;
    case CID_LOGIN_REQ_LOGINOUT:
        _HandleLoginOutRequest(pPdu);
        break;
            
	......
        
    case CID_FILE_ADD_OFFLINE_REQ:
        s_file_handler->HandleClientFileAddOfflineReq(this, pPdu);
        break;
    case CID_FILE_DEL_OFFLINE_REQ:
        s_file_handler->HandleClientFileDelOfflineReq(this, pPdu);
        break;
    default:
        log("wrong msg, cmd id=%d, user id=%u. ", pPdu->GetCommandId(), GetUserId());
        break;
    }
}
```

##### MsgConn.h->CMsgConn::_HandleLoginRequest

```cpp
//向db_proxy_server发送用户登录认证请求
void CMsgConn::_HandleLoginRequest(CImPdu* pPdu)
{   
    // 1.检查是否已经存在登录名 如果存在则打印相应的日志信息，并直接返回拒绝重复的登录请求
    if (m_login_name.length() != 0) {
        log("duplicate LoginRequest in the same conn ");
        return;
    }

    // 2.检查各个服务器连接的可用性 包括数据库服务器连接和路由服务器连接
    uint32_t result = 0;
    string result_string = "";
    // 获取数据库服务器连接对象 pDbConn
    CDBServConn* pDbConn = get_db_serv_conn_for_login();
    if (!pDbConn) {
        //没有数据库服务器连接 表示拒绝登录
        result = IM::BaseDefine::REFUSE_REASON_NO_DB_SERVER;
        result_string = "服务端异常";
    } else if (!is_login_server_available()) {
        //登录服务器不可用
        result = IM::BaseDefine::REFUSE_REASON_NO_LOGIN_SERVER;
        result_string = "服务端异常";
    } else if (!is_route_server_available()) {
        //路由服务器不可用
        result = IM::BaseDefine::REFUSE_REASON_NO_ROUTE_SERVER;
        result_string = "服务端异常";
    }

    // 3.如果存在拒绝登录的情况（result不为0）则会发送登录响应消息给客户端，并关闭连接
    if (result) {
        // 3-1.创建一个IM::Login::IMLoginRes对象msg 并设置该对象的字段值
        IM::Login::IMLoginRes msg;
        // 3-2.设置相关响应消息 
        msg.set_server_time(time(NULL));//设置为当前时间
        msg.set_result_code((IM::BaseDefine::ResultType)result);//设置为result的值，表示拒绝原因
        msg.set_result_string(result_string);//设置为result_string的值，表示结果说明
        // 3-3.创建一个CImPdu对象pdu，并将msg对象设置为其消息体
        CImPdu pdu;
        pdu.SetPBMsg(&msg);//将 msg 对象设置为其消息体
        pdu.SetServiceId(SID_LOGIN);//设置pdu的服务ID为SID_LOGIN
        pdu.SetCommandId(CID_LOGIN_RES_USERLOGIN); //命令ID为CID_LOGIN_RES_USERLOGIN
        pdu.SetSeqNum(pPdu->GetSeqNum());//消息序列号为登录请求消息的序列号
        // 3-4.调用SendPdu方法将登录响应消息发送给客户端
        SendPdu(&pdu);
        // 3-5.最后调用Close方法关闭连接结束处理
        Close();// 关闭 CMsgConn* pConn = new CMsgConn(); 什么时候释放资源
        return;
    }

    // 4.服务器连接都正常，则继续处理登录请求
    IM::Login::IMLoginReq msg;
    // 4-1.解析登录请求消息的内容
    // 该方法将消息的二进制数据解析为 IM::Login::IMLoginReq 对象 msg
    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()));

    // 4-2.设置消息中的信息到私有成员变量中
    m_login_name = msg.user_name();//登录请求中的用户名
    string password = msg.password();//登录请求中的密码
    //检查在线状态的取值范围是否有效 如果不在有效范围内 会打印相应的日志信息，并将在线状态设置为默认值
    uint32_t online_status = msg.online_status();
    if (online_status < IM::BaseDefine::USER_STATUS_ONLINE || online_status > IM::BaseDefine::USER_STATUS_LEAVE) {
        log("HandleLoginReq, online status wrong: %u ", online_status);
        online_status = IM::BaseDefine::USER_STATUS_ONLINE;
    }
    m_client_version = msg.client_version();//客户端版本
    m_client_type = msg.client_type();//客户端类型
    m_online_status = online_status;//在线状态
    log("HandleLoginReq, user_name=%s, status=%u, client_type=%u, client=%s, ",
        m_login_name.c_str(), online_status, m_client_type, m_client_version.c_str());

    // 5.用户重复登录验证
    // 通过调用 CImUserManager::GetInstance()->GetImUserByLoginName(GetLoginName()) 方法
    // 5-1.根据登录名获取对应的 CImUser 对象 pImUser
    CImUser* pImUser = CImUserManager::GetInstance()->GetImUserByLoginName(GetLoginName());

    // 5-2.如果pImUser为空，表示该用户尚未存在创建一个新的CImUser对象，并将其添加到用户管理器中
    if (!pImUser) {
        pImUser = new CImUser(GetLoginName()); // 新建一个用户
        CImUserManager::GetInstance()->AddImUserByLoginName(GetLoginName(), pImUser);
    }

    // 6.将验证消息转发到 db_proxy_server 进行身份验证
    // 6-1.将当前连接（this）添加到用户的未验证连接列表中
    pImUser->AddUnValidateMsgConn(this);

    // 6-2.创建 CDbAttachData 对象 attach_data，该对象用于传递附加数据给数据库代理服务器
    // 将连接的句柄（m_handle）作为附加数据，用于后续验证的过程中标识连接
    CDbAttachData attach_data(ATTACH_TYPE_HANDLE, m_handle, 0);

    // 6-3.创建IM::Server::IMValidateReq对象msg2消息体，并将用户名、密码和附加数据设置到该对象中
    IM::Server::IMValidateReq msg2;
    msg2.set_user_name(msg.user_name());//用户名
    msg2.set_password(password);//密码
    msg2.set_attach_data(attach_data.GetBuffer(), attach_data.GetLength());//附加数据

    // 6-4.设置pdu的服务ID为SID_OTHER，命令ID为CID_OTHER_VALIDATE_REQ，序列号为原始登录请求的序列号
    CImPdu pdu;
    pdu.SetPBMsg(&msg2);
    pdu.SetServiceId(SID_OTHER);
    pdu.SetCommandId(CID_OTHER_VALIDATE_REQ);
    pdu.SetSeqNum(pPdu->GetSeqNum());

    // 6-5.通过数据库代理连接对象pDbConn调用SendPdu()方法，将验证请求 pdu 发送给数据库代理服务器进行验证
    pDbConn->SendPdu(&pdu);
}
```

##### HandlerMap.h->CHandlerMap::Init

```cpp
//CHandlerMap初始化函数,加载了各种commandId 对应的处理函数
void CHandlerMap::Init() {
    // Login validate
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin));
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY::doPushShield));
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY::doQueryPushShield));

    // recent session
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY::getRecentSession));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY::deleteRecentSession));

    // users
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY::getUserInfo));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY::getChangedUser));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY::getChgedDepart));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY::changeUserSignInfo));

    // message content
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_DATA), DB_PROXY::sendMessage));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_LIST_REQUEST), DB_PROXY::getMessage));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY::getUnreadMsgCounter));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_READ_ACK), DB_PROXY::clearUnreadMsgCounter));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY::getMessageById));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY::getLatestMsgId));

    // device token
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY::setDevicesToken));
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY::getDevicesToken));

    // push 推送设置
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY::setGroupPush));
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_SHIELD_REQ), DB_PROXY::getGroupPush));

    // group
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY::getNormalGroupList));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_INFO_REQUEST), DB_PROXY::getGroupInfo));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CREATE_REQUEST), DB_PROXY::createGroup));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY::modifyMember));

    // file
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY::hasOfflineFile));
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY::addOfflineFile));
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY::delOfflineFile));
}
```

##### Login.h->DB_PROXY::doLogin

根据对应的map映射关系，可以找到CID_OTHER_VALIDATE_REQ请求相应的处理方法，

```cpp
namespace DB_PROXY {

void doLogin(CImPdu* pPdu, uint32_t conn_uuid) {
    //创建一个用于响应的CImPdu对象pPduResp
    CImPdu* pPduResp = new CImPdu;
    //创建一个登录响应消息msgResp
    IM::Server::IMValidateRsp msgResp;
    IM::Server::IMValidateReq msg;

    // 1.解析登录请求中的用户名和密码 并将其存储到 strDomain 和 strPass 变量中
    if (msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
        string strDomain = msg.user_name();//用户名
        string strPass = msg.password();//密码

        // 2.创建一个登录响应消息msgResp 设置用户名和附加数据
        msgResp.set_user_name(strDomain);
        msgResp.set_attach_data(msg.attach_data());

        // 3.检查登录限制
        do {
            // 3-1.使用 g_cLimitLock 对登录限制进行加锁
            CAutoLock cAutoLock(&g_cLimitLock);
            // 3-2.从 g_hmLimits 哈希表中获取对应用户名的错误登录时间列表 lsErrorTime
            list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];

            // 3-3.清理超过30分钟的错误登录时间点记录
            uint32_t tmNow = time(NULL);
            auto itTime = lsErrorTime.begin();
            for (; itTime != lsErrorTime.end(); ++itTime) {
                if (tmNow - *itTime > 30 * 60) {
                    break;
                }
            }
        
            //清理放在这里还是放在密码错误后添加的时候呢？
            //放在这里，每次都要遍历，会有一点点性能的损失。
            //放在后面，可能会造成30分钟之前有10次错的，但是本次是对的就没办法再访问了
            
            if (itTime != lsErrorTime.end()) {
                lsErrorTime.erase(itTime, lsErrorTime.end());
            }

            // 3-4.判断30分钟内密码错误次数是否大于10
            if (lsErrorTime.size() > 10) {
                itTime = lsErrorTime.begin();
                if (tmNow - *itTime <= 30 * 60) {
                    // 如果超过限制，则返回登录失败响应
                    msgResp.set_result_code(6);
                    msgResp.set_result_string("用户名/密码错误次数太多");
                    pPduResp->SetPBMsg(&msgResp);
                    pPduResp->SetSeqNum(pPdu->GetSeqNum());
                    pPduResp->SetServiceId(IM::BaseDefine::SID_OTHER);
                    pPduResp->SetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP);
                    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
                    return;
                }
            }
        } while (false);

        // 4.记录登录请求日志
        log("%s request login.", strDomain.c_str());

        // 5.调用 g_loginStrategy 的doLogin()函数进行实际的登录验证，传入用户名、密码和用户信息参数
        IM::BaseDefine::UserInfo cUser;
        if (g_loginStrategy.doLogin(strDomain, strPass, cUser)) {
            // 5-1.如果登录验证成功，将用户信息填充到登录响应消息中，并设置登录成功的结果码和结果字符串
            IM::BaseDefine::UserInfo* pUser = msgResp.mutable_user_info();
            pUser->set_user_id(cUser.user_id());//uid
            pUser->set_user_gender(cUser.user_gender());//gender
            pUser->set_department_id(cUser.department_id());//department
            pUser->set_user_nick_name(cUser.user_nick_name());//nick_name
            pUser->set_user_domain(cUser.user_domain());//domain
            pUser->set_avatar_url(cUser.avatar_url());//avator_url

            pUser->set_email(cUser.email());//email
            pUser->set_user_tel(cUser.user_tel());//tel
            pUser->set_user_real_name(cUser.user_real_name());//real_name
            pUser->set_status(0);//status

            pUser->set_sign_info(cUser.sign_info());//用户个性签名

            msgResp.set_result_code(0);//result_code
            msgResp.set_result_string("成功");//result_string

            // 如果登陆成功，则清除错误尝试限制
            CAutoLock cAutoLock(&g_cLimitLock);
            list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];
            lsErrorTime.clear();
        } else {
            // 5-2.如果登录验证失败，记录一次登录失败，并设置登录失败的结果码和结果字符串
            // 获取当前时间戳 tmCurrent，用于记录错误登录的时间
            uint32_t tmCurrent = time(NULL);
            // 使用互斥锁 g_cLimitLock 对登录限制进行加锁，以确保多线程环境下的数据安全性
            CAutoLock cAutoLock(&g_cLimitLock);
            // 通过用户名 strDomain 在 g_hmLimits 哈希表中获取对应的错误登录时间列表 lsErrorTime
            list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];
            // 将当前时间戳 tmCurrent 插入到错误登录时间列表 lsErrorTime 的头部，表示发生了一次错误登录
            lsErrorTime.push_front(tmCurrent);

            // 输出日志信息，提示用户名/密码错误
            log("get result false");
            // 设置登录响应消息的结果码为 1，表示用户名/密码错误
            msgResp.set_result_code(1);
            msgResp.set_result_string("用户名/密码错误");
        }
    } else {
        // 6.如果登录请求解析失败，设置内部错误的结果码和结果字符串
        msgResp.set_result_code(2);
        msgResp.set_result_string("服务端内部错误");
    }

    // 7.将登录响应消息发送回客户端
    pPduResp->SetPBMsg(&msgResp);//设置消息体
    pPduResp->SetSeqNum(pPdu->GetSeqNum());//设置消息序号
    pPduResp->SetServiceId(IM::BaseDefine::SID_OTHER);//SetServiceId
    pPduResp->SetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP);//command_id CID_OTHER_VALIDATE_RSP
    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);//AddResponsePdu
}

};
```

##### InterLogin.h->CInterLoginStrategy::doLogin

```cpp
bool CInterLoginStrategy::doLogin(const std::string& strName, const std::string& strPass, IM::BaseDefine::UserInfo& user) {
    bool bRet = false;
    // 1.获取数据库连接对象 pDBConn
    CDBManager* pDBManger = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManger->GetDBConn("teamtalk_slave");

    if (pDBConn) {
        // 2.构造SQL查询语句，通过用户名strName查询符合条件的用户信息
        string strSql = "select * from IMUser where name='" + strName + "' and status=0";
        // 3.执行 SQL 查询并获取结果集 pResultSet
        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
        if (pResultSet) {
            string strResult, strSalt;
            uint32_t nId, nGender, nDeptId, nStatus;
            string strNick, strAvatar, strEmail, strRealName, strTel, strDomain, strSignInfo;
            // 4.遍历结果集，提取出查询到的用户信息，包括用户的 ID、密码、盐值以及其他相关字段
            while (pResultSet->Next()) {
                nId = pResultSet->GetInt("id");
                strResult = pResultSet->GetString("password");
                strSalt = pResultSet->GetString("salt");

                strNick = pResultSet->GetString("nick");
                nGender = pResultSet->GetInt("sex");
                strRealName = pResultSet->GetString("name");
                strDomain = pResultSet->GetString("domain");
                strTel = pResultSet->GetString("phone");
                strEmail = pResultSet->GetString("email");
                strAvatar = pResultSet->GetString("avatar");
                nDeptId = pResultSet->GetInt("departId");
                nStatus = pResultSet->GetInt("status");
                strSignInfo = pResultSet->GetString("sign_info");
            }

            // 5.将输入的密码 strPass 和 混淆值拼接，然后计算MD5值得到 strOutPass
            string strInPass = strPass + strSalt;
            char szMd5[33];
            CMd5::MD5_Calculate(strInPass.c_str(), strInPass.length(), szMd5);
            string strOutPass(szMd5);

            // 6.将计算得到的 strOutPass 与数据库查询到的密码进行比较，如果相等则表示登录验证成功
            if (strOutPass == strResult) {
                // 7.如果登录验证成功，将相应的用户信息设置到user对象中，并将返回值bRet设置为 true表示登录验证成功
                bRet = true;
                user.set_user_id(nId);
                user.set_user_nick_name(strNick);
                user.set_user_gender(nGender);
                user.set_user_real_name(strRealName);
                user.set_user_domain(strDomain);
                user.set_user_tel(strTel);
                user.set_email(strEmail);
                user.set_avatar_url(strAvatar);
                user.set_department_id(nDeptId);
                user.set_status(nStatus);
                user.set_sign_info(strSignInfo);
            }
            delete pResultSet;
        }
        pDBManger->RelDBConn(pDBConn);
    }
    return bRet;
}
```

##### DBServConn.h->HandlePdu

![image-20230522111542151](assets/image-20230522111542151.png)

```cpp
void CDBServConn::HandlePdu(CImPdu* pPdu) {
    switch (pPdu->GetCommandId()) {
    case CID_OTHER_HEARTBEAT:
        break;
    case CID_OTHER_VALIDATE_RSP:
        _HandleValidateResponse(pPdu);
        break;
    case CID_LOGIN_RES_DEVICETOKEN:
        _HandleSetDeviceTokenResponse(pPdu);
        break;
            
     ......
            
    case CID_FILE_HAS_OFFLINE_RES:
        s_file_handler->HandleFileHasOfflineRes(pPdu);
        break;

    default:
        log("db server, wrong cmd id=%d ", pPdu->GetCommandId());
    }
}
```

##### DBServConn.h->CDBServConn::_HandleValidateResponse

```cpp
//处理验证响应消息的函数 
void CDBServConn::_HandleValidateResponse(CImPdu* pPdu) {
    IM::Server::IMValidateRsp msg;
    // 1.解析验证响应消息 获取登录名 login_name、结果码 result 和 结果字符串 result_string
    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()));
    string login_name = msg.user_name();
    uint32_t result = msg.result_code();
    string result_string = msg.result_string();

    // 2.根据附加数据构造 CDbAttachData 对象
    CDbAttachData attach_data((uchar_t*)msg.attach_data().c_str(), msg.attach_data().length());
    log("HandleValidateResp, user_name=%s, result=%d", login_name.c_str(), result);

    // 3.根据登录名获取用户对象 pImUser 记录日志
    CImUser* pImUser = CImUserManager::GetInstance()->GetImUserByLoginName(login_name);
    CMsgConn* pMsgConn = NULL;
    if (!pImUser) {
        // 如果用户对象存在，则根据附加数据的句柄获取未验证的消息连接对象 pMsgConn
        log("ImUser for user_name=%s not exist", login_name.c_str());
        return;
    } else {
        // 如果 pMsgConn 不存在或者已经打开，则记录日志并返回
        pMsgConn = pImUser->GetUnValidateMsgConn(attach_data.GetHandle());
        if (!pMsgConn || pMsgConn->IsOpen()) {
            log("no such conn is validated, user_name=%s", login_name.c_str());
            return;
        }
    }

    // 4.如果结果码 result 不为零，将结果码重置为 IM::BaseDefine::REFUSE_REASON_DB_VALIDATE_FAILED
    if (result != 0) result = IM::BaseDefine::REFUSE_REASON_DB_VALIDATE_FAILED;

    // 5.如果结果码为零表示验证成功，继续处理验证成功的逻辑
    if (result == 0) {
        // 5-1.获取用户信息 user_info  user_id  用户对象pUser
        IM::BaseDefine::UserInfo user_info = msg.user_info();
        uint32_t user_id = user_info.user_id();
        CImUser* pUser = CImUserManager::GetInstance()->GetImUserById(user_id);
        if (pUser) {
            // 已存在该ID的用户对象 pUser 则将该连接添加到 pUser 的未验证连接列表中，并从 pImUser 的未验证连接列表中删除
            pUser->AddUnValidateMsgConn(pMsgConn);
            pImUser->DelUnValidateMsgConn(pMsgConn);
            // 如果 pImUser 的未验证连接列表为空，表示没有其他未验证的连接了，可以移除该用户对象
            if (pImUser->IsMsgConnEmpty()) {
                CImUserManager::GetInstance()->RemoveImUserByLoginName(login_name);
                delete pImUser;
            }
        } else {
            // 如果用户对象 pUser 不存在，则将 pUser 设置为 pImUser
            pUser = pImUser;
        }

        // 5-2.设置 pUser 的用户ID、昵称、验证状态
        pUser->SetUserId(user_id);//uid
        pUser->SetNickName(user_info.user_nick_name());//nick_name
        pUser->SetValidated();//SetValidated
        CImUserManager::GetInstance()->AddImUserById(user_id, pUser);

        // 5-3.根据连接的客户端类型踢出相同类型的重复用户
        pUser->KickOutSameClientType(pMsgConn->GetClientType(), IM::BaseDefine::KICK_REASON_DUPLICATE_USER, pMsgConn);

        // 5-4.获取路由服务器连接 pRouteConn，如果存在则向路由服务器发送踢出用户的消息
        CRouteServConn* pRouteConn = get_route_serv_conn();
        if (pRouteConn) {
            IM::Server::IMServerKickUser msg2;
            msg2.set_user_id(user_id);
            msg2.set_client_type((::IM::BaseDefine::ClientType)pMsgConn->GetClientType());
            msg2.set_reason(1);
            CImPdu pdu;
            pdu.SetPBMsg(&msg2);
            pdu.SetServiceId(SID_OTHER);
            pdu.SetCommandId(CID_OTHER_SERVER_KICK_USER);//踢出用户的消息
            pRouteConn->SendPdu(&pdu);
        }
        log("user_name: %s, uid: %d", login_name.c_str(), user_id);

        // 5-5.设置连接的用户ID、打开状态，并发送用户状态更新的消息
        pMsgConn->SetUserId(user_id);
        pMsgConn->SetOpen();
        pMsgConn->SendUserStatusUpdate(IM::BaseDefine::USER_STATUS_ONLINE);
        pUser->ValidateMsgConn(pMsgConn->GetHandle(), pMsgConn);

        // 5-6.构造登录响应消息 msg3，设置相关字段
        IM::Login::IMLoginRes msg3;
        msg3.set_server_time(time(NULL));
        msg3.set_result_code(IM::BaseDefine::REFUSE_REASON_NONE);
        msg3.set_result_string(result_string);
        msg3.set_online_status((IM::BaseDefine::UserStatType)pMsgConn->GetOnlineStatus());
        IM::BaseDefine::UserInfo* user_info_tmp = msg3.mutable_user_info();
        user_info_tmp->set_user_id(user_info.user_id());
        user_info_tmp->set_user_gender(user_info.user_gender());
        user_info_tmp->set_user_nick_name(user_info.user_nick_name());
        user_info_tmp->set_avatar_url(user_info.avatar_url());
        user_info_tmp->set_sign_info(user_info.sign_info());
        user_info_tmp->set_department_id(user_info.department_id());
        user_info_tmp->set_email(user_info.email());
        user_info_tmp->set_user_real_name(user_info.user_real_name());
        user_info_tmp->set_user_tel(user_info.user_tel());
        user_info_tmp->set_user_domain(user_info.user_domain());
        user_info_tmp->set_status(user_info.status());

        // 5-6.构造登录响应消息Pdu pdu2，设置相关字段
        CImPdu pdu2;
        pdu2.SetPBMsg(&msg3);//消息体
        pdu2.SetServiceId(SID_LOGIN);//service_id
        pdu2.SetCommandId(CID_LOGIN_RES_USERLOGIN);//新的command_id CID_LOGIN_RES_USERLOGIN
        pdu2.SetSeqNum(pPdu->GetSeqNum());//设置消息序号

        // 5-7.发送登录响应消息给客户端
        pMsgConn->SendPdu(&pdu2);
    } else {
        // 6.如果结果码不为零，表示验证失败，继续处理验证失败的逻辑
        // 6-1.构造登录响应消息 msg4，设置相关字段
        IM::Login::IMLoginRes msg4;
        msg4.set_server_time(time(NULL));
        msg4.set_result_code((IM::BaseDefine::ResultType)result);
        msg4.set_result_string(result_string);

        // 6-2.构造登录响应消息Pdu pdu2，设置相关字段
        CImPdu pdu3;
        pdu3.SetPBMsg(&msg4);//消息体
        pdu3.SetServiceId(SID_LOGIN);//service_id
        pdu3.SetCommandId(CID_LOGIN_RES_USERLOGIN);//command_id CID_LOGIN_RES_USERLOGIN
        pdu3.SetSeqNum(pPdu->GetSeqNum());
        pMsgConn->SendPdu(&pdu3);

        // 6-3.关闭连接
        pMsgConn->Close();
    }
}
```

