# 数据更新全流程

---

这⾥略过登录流程，即是略过CID_LOGIN_REQ_USERLOGIN到CID_OTHER_LOGIN_STATUS_NOTIFY。

即时通讯本地肯定是要做数据缓存的，包括用户信息、好友关系、消息，两种更新模式：

- 全量更新：本地没有缓存的数据
- 增量更新：本地已有缓存的数据（通过比较latest_update_time时间来确定）

![image-20230522120603037](assets/image-20230522120603037.png)

### 1.更新部门信息

![image-20230522133215003](assets/image-20230522133215003.png)

![image-20230522131556563](assets/image-20230522131556563.png)

1. 解析user_id和latest_update_time最近一次拉取信息
2. 数据库查找IMDepart表，对比其update字段，返回updated_latest_update_time的记录
3. 封装更新的部门信息到IMDepartmentRsp

本地没有缓存全量更新、本地有缓存增量更新CID_BUDDY_LIST_DEPARTMENT_REQUEST

- CMsgConn::_HandleClientDepartmentRequest：（msg_server模块）CID_BUDDY_LIST_DEPARTMENT_REQUEST，拉取部⻔信息
- 发送给db_proxy_server，DB_PROXY::getChgedDepart进⾏响应
  - CDepartModel::getChgedDeptId，IMDepart存储的是部⻔id信息，通过对⽐本地客户端更新的时间和服务器更新的时间进⾏对⽐，或者到已经更新了的部⻔ID信息
  - CDepartModel::getDepts，还是操作IMDepart，此时是读取出新更新部⻔的所有信息
  - 将更新的部⻔信息封装成pdu回发给msg_server，使⽤CID_BUDDY_LIST_DEPARTMENT_RESPONSE命令

- CDBServConn::_HandleDepartmentResponse （msg_server模块）响应，然后也以CID_BUDDY_LIST_DEPARTMENT_RESPONSE回发给客户端。

以拉取部门信息为例，分析客户端登录的逻辑流程：CID_BUDDY_LIST_DEPARTMENT_REQUEST

```cpp
// command id for buddy list
enum BuddyListCmdID{
    CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST       = 0x0201;   //最近联系人会话请求
    CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE      = 0x0202;
    CID_BUDDY_LIST_STATUS_NOTIFY                        = 0x0203;   //用户状态通知
    CID_BUDDY_LIST_USER_INFO_REQUEST                    = 0x0204;   //用户信息请求
    CID_BUDDY_LIST_USER_INFO_RESPONSE                   = 0x0205;
    //其中带了一个latest_update_time字段，请求应答会返回latest_update_time时间之后发生变化的用户回来 
    CID_BUDDY_LIST_REMOVE_SESSION_REQ                   = 0x0206;   //删除最近会话请求
    CID_BUDDY_LIST_REMOVE_SESSION_RES                   = 0x0207;
    CID_BUDDY_LIST_ALL_USER_REQUEST                     = 0x0208;   //所有用户请求
    CID_BUDDY_LIST_ALL_USER_RESPONSE                    = 0x0209;
    CID_BUDDY_LIST_USERS_STATUS_REQUEST                 = 0x020a;   //用户状态请求
    CID_BUDDY_LIST_USERS_STATUS_RESPONSE                = 0x020b;
    CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST                = 0x020c;   //更改头像请求(暂时未使用)
    CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE               = 0x020d;
    CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY               = 0x020e;   //PC登陆后通知移动端
    CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY                = 0x020f;   //删除会话后的通知，用于多端同步
    CID_BUDDY_LIST_DEPARTMENT_REQUEST                   = 0x0210;   //部门信息请求
    CID_BUDDY_LIST_DEPARTMENT_RESPONSE                  = 0x0211;
    CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY                = 0x0212;   //头像更改通知
    CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST             = 0x0213;   //修改个性签名请求
    CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE            = 0x0214;
    CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY             = 0x0215;   //签名修改通知
}
```

```cpp
/* IM.Buddy.proto */
message IMDepartmentReq{
	//cmd id:		0x0210
	required uint32 user_id = 1;
	required uint32 latest_update_time = 2;
	optional bytes attach_data = 20;
}

message IMDepartmentRsp{
	//cmd id:		0x0211
	required uint32 user_id = 1;
	required uint32 latest_update_time = 2;
	repeated IM.BaseDefine.DepartInfo dept_list = 3;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message DepartInfo{
	required uint32 dept_id = 1;
	required uint32 priority = 2;
	required string dept_name = 3;
    required uint32 parent_dept_id = 4;
    required DepartmentStatusType dept_status = 5;
}
```

##### MsgConn.h->HandlePdu

客户端连接msg_server，对应的请求处理都在MsgConn.cpp中实现，客户端请求CID_BUDDY_LIST_DEPARTMENT_REQUEST，

```cpp
//处理收到的PDU 根据PDU的命令ID，将其分派给相应的处理函数
void CMsgConn::HandlePdu(CImPdu* pPdu) {   
    // 1.检查pPdu的命令ID是否为CID_OTHER_HEARTBEAT（心跳命令）如果不是心跳命令，则打印相应的日志信息
    if (pPdu->GetCommandId() != CID_OTHER_HEARTBEAT)
        log("HandlePdu cmd:0x%04x\n", pPdu->GetCommandId()); // request authorization check
    // 2.检查pPdu的命令ID是否为CID_LOGIN_REQ_USERLOGIN（用户登录请求）并且当前连接是打开的并且被踢出的状态
    if (pPdu->GetCommandId() != CID_LOGIN_REQ_USERLOGIN && !IsOpen() && IsKickOff()) {
        //如果条件满足则打印相应的日志信息，并抛出一个CPduException异常，异常信息指示处理PDU时出错用户未登录
        log("HandlePdu, wrong msg. ");
        throw CPduException(pPdu->GetServiceId(), pPdu->GetCommandId(), ERROR_CODE_WRONG_SERVICE_ID, "HandlePdu error, user not login. ");
        return;
    }
    // 3.最后通过switch语句根据pPdu的命令ID执行相应的操作
    // 根据不同的命令ID，调用相应的私有方法来处理不同的请求，例如处理心跳、用户登录请求、用户登出请求等
    switch (pPdu->GetCommandId()) {
    case CID_OTHER_HEARTBEAT:
        _HandleHeartBeat(pPdu);
        break;
    case CID_LOGIN_REQ_USERLOGIN:
        _HandleLoginRequest(pPdu);
        break;
		
            ......

    case CID_BUDDY_LIST_USERS_STATUS_REQUEST:
        _HandleClientUsersStatusRequest(pPdu);
        break;
    case CID_BUDDY_LIST_DEPARTMENT_REQUEST:
        _HandleClientDepartmentRequest(pPdu);
        break;
    // for group process
    case CID_GROUP_NORMAL_LIST_REQUEST:
        s_group_chat->HandleClientGroupNormalRequest(pPdu, this);
        break;
    case CID_GROUP_INFO_REQUEST:
        s_group_chat->HandleClientGroupInfoRequest(pPdu, this);
        break;
            
            ......
            
    default:
        log("wrong msg, cmd id=%d, user id=%u. ", pPdu->GetCommandId(), GetUserId());
        break;
    }
}
```

##### MsgConn.h->_HandleClientDepartmentRequest

```cpp
//处理客户端部门信息请求
//当客户端发送部门信息请求时，服务器会调用此函数进行处理
void CMsgConn::_HandleClientDepartmentRequest(CImPdu* pPdu) {
    IM::Buddy::IMDepartmentReq msg;
    // 1.解析部门信息请求消息，获取用户ID和最新更新时间
    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()));
    log("HandleClientDepartmentRequest, user_id=%u, latest_update_time=%u.", GetUserId(), msg.latest_update_time()); 

    // 2.获取数据库服务器连接 pDBConn
    CDBServConn* pDBConn = get_db_serv_conn();

    // 3.如果存在数据库服务器连接 pDBConn，则进行以下操作
    if (pDBConn) {
        // 3-1.创建CDbAttachData对象attach，用于存储附加数据
        // 附加数据类型为 ATTACH_TYPE_HANDLE，句柄为当前连接的句柄，长度为0
        CDbAttachData attach(ATTACH_TYPE_HANDLE, m_handle, 0);
        // 3-2.设置部门信息请求消息的用户ID和附加数据
        msg.set_user_id(GetUserId());
        msg.set_attach_data(attach.GetBuffer(), attach.GetLength());
        // 3-3.将部门信息请求消息设置为待发送的消息对象 pPdu 的 消息体
        pPdu->SetPBMsg(&msg);
        // 3-4.调用数据库服务器连接 pDBConn的SendPdu方法将数据发送到 db_proxy_server
        pDBConn->SendPdu(pPdu);
    }
}
```



##### HandlerMap.h->CHandlerMap::Init

```cpp
//CHandlerMap初始化函数,加载了各种commandId 对应的处理函数
void CHandlerMap::Init() {
    // Login validate
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin));
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY::doPushShield));
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY::doQueryPushShield));

    // recent session
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY::getRecentSession));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY::deleteRecentSession));

    // users
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY::getUserInfo));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY::getChangedUser));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY::getChgedDepart));
    m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY::changeUserSignInfo));

    // message content
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_DATA), DB_PROXY::sendMessage));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_LIST_REQUEST), DB_PROXY::getMessage));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY::getUnreadMsgCounter));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_READ_ACK), DB_PROXY::clearUnreadMsgCounter));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY::getMessageById));
    m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY::getLatestMsgId));

    // device token
    m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY::setDevicesToken));
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY::getDevicesToken));

    // push 推送设置
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY::setGroupPush));
    m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_SHIELD_REQ), DB_PROXY::getGroupPush));

    // group
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY::getNormalGroupList));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_INFO_REQUEST), DB_PROXY::getGroupInfo));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CREATE_REQUEST), DB_PROXY::createGroup));
    m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY::modifyMember));

    // file
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY::hasOfflineFile));
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY::addOfflineFile));
    m_handler_map.insert(make_pair(uint32_t(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY::delOfflineFile));
}
```

##### DepartAction.h->CDepartModel::getChgedDept

```cpp
/// @brief 获取变更的部门信息
/// @param pPdu 指向 CImPdu 对象的指针
/// @param conn_uuid 连接的唯一标识符 conn_uuid
void getChgedDepart(CImPdu* pPdu, uint32_t conn_uuid) {
    // 创建一个空的部门信息响应消息对象 msgResp
    IM::Buddy::IMDepartmentReq msg;
    IM::Buddy::IMDepartmentRsp msgResp;
    // 解析收到的部门信息请求消息 获取用户ID和最新更新时间
    if (msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
        // 1.成功解析消息
        // 1-1.创建一个待发送的消息对象 pPduRes
        CImPdu* pPduRes = new CImPdu;
        uint32_t nUserId = msg.user_id();
        uint32_t nLastUpdate = msg.latest_update_time();

        // 1-2.从数据库中获取最新更新时间后发生变化的部门ID列表 lsChangedIds，以及对应的部门信息列表 lsDeparts
        list<uint32_t> lsChangedIds;
        CDepartModel::getInstance()->getChgedDeptId(nLastUpdate, lsChangedIds);
        list<IM::BaseDefine::DepartInfo> lsDeparts;
        CDepartModel::getInstance()->getDepts(lsChangedIds, lsDeparts);

        // 1-3.设置部门信息响应消息的用户ID和最新更新时间
        msgResp.set_user_id(nUserId);
        msgResp.set_latest_update_time(nLastUpdate);

        // 1-4.遍历部门信息列表，将每个部门信息添加到部门信息响应消息中
        for (auto it = lsDeparts.begin(); it != lsDeparts.end(); ++it) {
            IM::BaseDefine::DepartInfo* pDeptInfo = msgResp.add_dept_list();
            pDeptInfo->set_dept_id(it->dept_id());
            pDeptInfo->set_priority(it->priority());
            pDeptInfo->set_dept_name(it->dept_name());
            pDeptInfo->set_parent_dept_id(it->parent_dept_id());
            pDeptInfo->set_dept_status(it->dept_status());
        }
        log("userId=%u, last_update=%u, cnt=%u", nUserId, nLastUpdate, lsDeparts.size());

        // 1-5.设置附加数据为请求消息中的附加数据
        msgResp.set_attach_data(msg.attach_data());//设置附加消息
        pPduRes->SetPBMsg(&msgResp);//设置消息体
        pPduRes->SetSeqNum(pPdu->GetSeqNum());//设置消息序号
        pPduRes->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);//SetServiceId
        pPduRes->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_DEPARTMENT_RESPONSE);//SetCommandId

        // 1-6.将待发送的消息对象 pPduRes 添加到响应消息队列中，以便后续发送给客户端
        CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
    } else {
        // 2.解析消息失败 直接记录日志
        log("parse pb failed");
    }
}
```

##### DepartModel.h->getChgedDeptId

```cpp
//从数据库中获取最近更新时间后发生变化的部门ID列表
void CDepartModel::getChgedDeptId(uint32_t& nLastTime, list<uint32_t>& lsChangedIds) {
    // 1.获取 CDBManager 的单例实例
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");

    if (pDBConn) {
        // 2.如果成功获取到数据库连接对象
        // 2-1.构建SQL查询语句，查询IMDepart表中更新时间大于给定最后更新时间 nLastTime 的部门ID和更新时间
        string strSql = "select id, updated from IMDepart where updated > " + int2string(nLastTime);
        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());//结果集对象 pResultSet
        if (pResultSet) {
            //遍历结果集，对于每条记录获取部门ID和更新时间
            while (pResultSet->Next()) {
                uint32_t id = pResultSet->GetInt("id");//部门id
                uint32_t nUpdated = pResultSet->GetInt("updated");//更新时间
                //如果部门的更新时间大于当前最后更新时间 nLastTime，则更新 nLastTime 的值为部门的更新时间
                if (nLastTime < nUpdated) nLastTime = nUpdated;
                //将部门ID添加到变更的部门ID列表 lsChangedIds 中
                lsChangedIds.push_back(id);
            }
            delete pResultSet;
        }
        pDBManager->RelDBConn(pDBConn);
    } else {
        // 3.如果未能获取到数据库连接对象 记录错误日志
        log("no db connection for teamtalk_slave.");
    }
}
```

##### DepartModel.h->getDepts

```cpp
//从数据库中获取给定部门ID列表中的部门信息
void CDepartModel::getDepts(list<uint32_t>& lsDeptIds, list<IM::BaseDefine::DepartInfo>& lsDepts) {
    if (lsDeptIds.empty()) {
        log("list is empty");
        return;
    }

    // 1.获取 CDBManager 的单例实例
    CDBManager* pDBManager = CDBManager::getInstance();
    // 通过pDBManager获取一个指向teamtalk_slave数据库连接的CDBConn对象
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");

    if (pDBConn) {
        // 2.成功获取到数据库连接对象
        // 2-1.构建SQL查询语句，使用给定的部门ID列表构建查询条件
        string strClause;
        bool bFirst = true;
        for (auto it = lsDeptIds.begin(); it != lsDeptIds.end(); ++it) {
            if (bFirst) {
                bFirst = false;
                strClause += int2string(*it);
            } else {
                strClause += ("," + int2string(*it));
            }
        }
        string strSql = "select * from IMDepart where id in ( " + strClause + " )";

        // 2-2.执行SQL查询，获取结果集对象 pResultSet
        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
        if (pResultSet) {
            // 2-3.遍历结果集对于每条记录，获取部门的ID 父部门ID 部门名称 部门状态和优先级
            while (pResultSet->Next()) {
                IM::BaseDefine::DepartInfo cDept;
                uint32_t nId = pResultSet->GetInt("id");
                uint32_t nParentId = pResultSet->GetInt("parentId");
                string strDeptName = pResultSet->GetString("departName");
                uint32_t nStatus = pResultSet->GetInt("status");
                uint32_t nPriority = pResultSet->GetInt("priority");
                // 2-4.如果当前部门状态是有效的，创建一个 IM::BaseDefine::DepartInfo 对象，并设置其属性
                if (IM::BaseDefine::DepartmentStatusType_IsValid(nStatus)) {
                    cDept.set_dept_id(nId);
                    cDept.set_parent_dept_id(nParentId);
                    cDept.set_dept_name(strDeptName);
                    cDept.set_dept_status(IM::BaseDefine::DepartmentStatusType(nStatus));
                    cDept.set_priority(nPriority);
                    // 2-5.将部门信息对象添加到部门信息列表lsDepts中
                    lsDepts.push_back(cDept);
                }
            }
            delete pResultSet;
        }
        pDBManager->RelDBConn(pDBConn);
    } else {
        // 3.未能获取到数据库连接对象 则记录日志
        log("no db connection for teamtalk_slave");
    }
}
```

##### DBServConn.h->HandlePdu

```cpp
void CDBServConn::HandlePdu(CImPdu* pPdu) {
    switch (pPdu->GetCommandId()) {
    case CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE:
        _HandleChangeSignInfoResponse(pPdu);
        break;
    case CID_BUDDY_LIST_DEPARTMENT_RESPONSE:
        _HandleDepartmentResponse(pPdu);
        break;
    case CID_OTHER_GET_DEVICE_TOKEN_RSP:
        _HandleGetDeviceTokenResponse(pPdu);
        break;
    case CID_OTHER_GET_SHIELD_RSP:
        s_group_chat->HandleGroupGetShieldByGroupResponse(pPdu);
        break;
    case CID_OTHER_STOP_RECV_PACKET:
        _HandleStopReceivePacket(pPdu);
        break;
		
            ......
            
    case CID_GROUP_SHIELD_GROUP_RESPONSE:
        s_group_chat->HandleGroupShieldGroupResponse(pPdu);
        break;
    case CID_FILE_HAS_OFFLINE_RES:
        s_file_handler->HandleFileHasOfflineRes(pPdu);
        break;
    default:
        log("db server, wrong cmd id=%d ", pPdu->GetCommandId());
    }
}
```

##### DBServConn.h->_HandleDepartmentResponse

```cpp
//处理部门信息的响应
void CDBServConn::_HandleDepartmentResponse(CImPdu* pPdu) {
    // 1.解析收到的部门信息响应消息，将消息内容存储在 IM::Buddy::IMDepartmentRsp 类型的 msg 对象中
    IM::Buddy::IMDepartmentRsp msg;
    CHECK_PB_PARSE_MSG(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()));

    // 2.获取用户ID、最新更新时间和部门数量等信息
    uint32_t user_id = msg.user_id();
    uint32_t latest_update_time = msg.latest_update_time();
    uint32_t dept_cnt = msg.dept_list_size();
    log("HandleDepartmentResponse, user_id=%u, latest_update_time=%u, dept_cnt=%u.", user_id, latest_update_time, dept_cnt);

    // 3.解析附加数据，将其转换为 CDbAttachData 对象，获取句柄（handle）
    CDbAttachData attach_data((uchar_t*)msg.attach_data().c_str(), msg.attach_data().length());

    // 4.通过用户ID和句柄获取与之关联的消息连接对象 pConn
    uint32_t handle = attach_data.GetHandle();
    CMsgConn* pConn = CImUserManager::GetInstance()->GetMsgConnByHandle(user_id, handle);

    // 5.如果消息连接对象存在且处于打开状态
    if (pConn && pConn->IsOpen()) {
        //清除附加数据中的内容
        msg.clear_attach_data();
        //设置响应消息的内容为解析后的 msg 对象
        pPdu->SetPBMsg(&msg);
        //将响应消息发送给消息连接对象
        pConn->SendPdu(pPdu);
    }
}
```





### 2.更新用户列表的用户信息

![image-20230522133326366](assets/image-20230522133326366.png)

![image-20230522133448150](assets/image-20230522133448150.png)

![image-20230522145934619](assets/image-20230522145934619.png)

CID_BUDDY_LIST_ALL_USER_REQUEST

- CMsgConn::_HandleClientAllUserRequest （msg_server模块）⽤户信息请求，使⽤CID_BUDDY_LIST_ALL_USER_REQUEST命令，并转发给db_proxy_server
- DB_PROXY::getChangedUser （db_proxy_server模块）（会把IM库⾥⾯所有⼈的⽤户信息都会回发，假如公司有个1万⼈，第⼀次安装的时候直接拉取⼀万⼈的信息）
  - 检测是否有⽤户信息更新，主要是通过对⽐客户端本地的最近更新时间和服务器的最新更新时间
  - 如果有更新 CUserModel::getChangedId获取更新的⽤户id
  - 获取有更新的⽤户信息CUserModel::getUsers
  - 封装到pdu使⽤CID_BUDDY_LIST_ALL_USER_RESPONSE命令回发给msg_server

- CDBServConn::_HandleAllUserResponse 进⾏响应，然后回发给客户端

```cpp
/* IM.Buddy.proto */
message IMAllUserReq{
	//cmd id:		0x0208
	required uint32 user_id = 1;
	required uint32 latest_update_time = 2;
	optional bytes attach_data = 20;
}

message IMAllUserRsp{
	//cmd id:		0x0209
	required uint32 user_id = 1;
	required uint32 latest_update_time = 2;
	repeated IM.BaseDefine.UserInfo user_list = 3;		
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message UserInfo{
	required uint32 user_id = 1;
	required uint32 user_gender = 2; 	//// 用户性别,男：1 女：2 人妖/外星人：0
	required string user_nick_name = 3;	//绰号
	required string avatar_url = 4;
	required uint32 department_id = 5;
	required string email = 6;
	required string user_real_name = 7;	//真名
	required string user_tel = 8;
	required string user_domain = 9;	//用户名拼音
    required uint32 status = 10;        //0:在职  1. 试用期 2. 正式 3. 离职 4.实习,  client端需要对“离职”进行不展示
    optional string sign_info = 11;
}
```





### 3.更新群组id列表

查询总共有多少个分组、总共有多少个群聊，根据用户id查找对应的群聊

![image-20230522150257765](assets/image-20230522150257765.png)

![image-20230522150335241](assets/image-20230522150335241.png)

```cpp
/* IM.Group.proto */
message IMNormalGroupListReq{
	//cmd id:			0x0401
	required uint32 user_id = 1;
	optional bytes attach_data = 20;
}

message IMNormalGroupListRsp{
	//cmd id:			0x0402
	required uint32 user_id = 1;
	repeated IM.BaseDefine.GroupVersionInfo group_version_list = 2;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message GroupVersionInfo{
	required uint32 group_id = 1;
	required uint32 version = 2;
}
```

GroupVersionInfo实际上是将群号与群版本返回，

群的id与群的详细信息是分开的，主要是因为群的信息不单单是指群的名称，群信息中还包含群用户等信息（信息较多），

问：群成员是从数据库中读取，还是从缓存中读取？

![image-20230522153616042](assets/image-20230522153616042.png)

### 4.更新群组具体消息

用户id与用户信息是一同返回来的，而群组的id与群组成员的信息是分开请求的，群成员的信息很多，同时请求会影响系统的效率。

![image-20230522152028744](assets/image-20230522152028744.png)

![image-20230522152100556](assets/image-20230522152100556.png)

```cpp
/* IM.Group.proto */
message IMGroupInfoListReq{
	//cmd id:			0x0403
	required uint32 user_id = 1;
	repeated IM.BaseDefine.GroupVersionInfo group_version_list = 2;
	optional bytes attach_data = 20;
}

message IMGroupInfoListRsp{
	//cmd id:			0x0404
	required uint32 user_id = 1;
	repeated IM.BaseDefine.GroupInfo group_info_list = 2;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message GroupInfo{
	required uint32 group_id = 1;
	required uint32 version = 2;
	required string group_name = 3;
	required string group_avatar = 4;
	required uint32 group_creator_id = 5;
	required GroupType group_type = 6;
	required uint32 shield_status = 7;		//1: shield  0: not shield 
	repeated uint32 group_member_list = 8;
}
```

![image-20230522153630136](assets/image-20230522153630136.png)





### 5.获取最近联系的会话

![image-20230522153653857](assets/image-20230522153653857.png)

![image-20230522154052695](assets/image-20230522154052695.png)

CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST

- CMsgConn::_HandleClientRecentContactSessionRequest，使⽤CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST命令，并转发给db_proxy_server
- DB_PROXY::getRecentSession (db_proxy_server模块)进⾏响应
  - 使⽤getRecentSession在IMRecentSession查询最近联系⼈列表信息，以及对应的详细信息，⽐如最后的消息msgId
  - CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE回复给msg_server

- CDBServConn::_HandleRecentSessionResponse （msg_server模块），回复给客户端。

```cpp
/* IM.Buddy.proto */
message IMRecentContactSessionReq{
	//cmd id:		0x0201
	required uint32 user_id = 1;
	required uint32 latest_update_time = 2;
	optional bytes attach_data = 20;
}

message IMRecentContactSessionRsp{
	//cmd id:		0x0202
	required uint32 user_id = 1;
	repeated IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message ContactSessionInfo{
	required uint32 session_id = 1;
	required SessionType session_type = 2;
    required SessionStatusType session_status = 3;
	required uint32 updated_time = 4;
	required uint32 latest_msg_id = 5;
	required bytes latest_msg_data = 6;
    required MsgType latest_msg_type = 7;
    required uint32 latest_msg_from_user_id = 8;
}
```

![image-20230522153939954](assets/image-20230522153939954.png)





### 6.查询⽤户列表的⽤户当前的在线状态

![image-20230522154110110](assets/image-20230522154110110.png)

- CMsgConn::_HandleClientUsersStatusRequest（msg_server模块），去route_server查询⽤户列表⾥⾯⽤户的状态，使⽤CID_BUDDY_LIST_USERS_STATUS_REQUEST命令，并由route_server进⾏⼴播
- CRouteConn::_HandleUsersStatusRequest (route_server模块)，从route_server的UserInfoMap_t g_user_map;⾥⾯获取user的当前状态。
  - 回复给msg_server CID_BUDDY_LIST_USERS_STATUS_RESPONSE
  - CRouteServConn::_HandleUsersStatusResponse进⾏响应，并以CID_BUDDY_LIST_USERS_STATUS_RESPONSE回复客户端。

```cpp
/* IM.Buddy.proto */
message IMUsersStatReq{
	//cmd id:		0x020a
	required uint32 user_id = 1;
	repeated uint32 user_id_list = 2;
	optional bytes attach_data = 20;
}

message IMUsersStatRsp{
	//cmd id:		0x020b
	required uint32 user_id = 1;
	repeated IM.BaseDefine.UserStat user_stat_list = 2;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message UserStat{
	required uint32 user_id = 1;
	required UserStatType status = 2;
}

enum UserStatType{
	USER_STATUS_ONLINE 	= 1;
	USER_STATUS_OFFLINE	= 2;
	USER_STATUS_LEAVE	= 3;
}
```





### 7.获取未读消息的数量

设计redis与mysql相关问题，

![image-20230522154406348](assets/image-20230522154406348.png)

![image-20230522154651252](assets/image-20230522154651252.png)

CID_MSG_UNREAD_CNT_REQUEST

- CMsgConn::_HandleClientUnreadMsgCntRequest （msg_server模块），使⽤CID_MSG_UNREAD_CNT_REQUEST命令，并转发给db_proxy_server
- DB_PROXY::getUnreadMsgCounter (db_proxy_server模块)（根据CID_MSG_UNREAD_CNT_REQUEST命令查找），未读消息数量包括单聊和群聊消息
  - CMessageModel::getUnreadMsgCount获取单聊未读消息数量
    - 未读消息数量存储在redis，以列表的⽅式进⾏存储，列表list包括<session_id,unread_cnt>
    - 调⽤CMessageModel::getLastMsg读取最新的消息

  - CMessageModel::getUnreadMsgCount获取群聊未读消息数量
  - 封装成pdu⽤CID_MSG_UNREAD_CNT_RESPONSE命令进⾏回发

- CDBServConn::_HandleUnreadMsgCountResponse（msg_server模块）进⾏响应，然后回发给客户端

```cpp
/* IM.Message.proto */
message IMUnreadMsgCntReq{
	//cmd id:		0x0307
	required uint32 user_id = 1;
	optional bytes attach_data = 20;	
}

message IMUnreadMsgCntRsp{
	//cmd id:		0x0308
	required uint32 user_id = 1;
	required uint32 total_cnt = 2;
	repeated IM.BaseDefine.UnreadInfo unreadinfo_list = 3;
	optional bytes attach_data = 20;
}
```

```cpp
/* IM.BaseDefine.proto */
message UnreadInfo{
	required uint32 session_id = 1;
	required SessionType session_type = 2;
	required uint32 unread_cnt = 3;
	required uint32 latest_msg_id = 4;
	required bytes latest_msg_data = 5;
    required MsgType latest_msg_type = 6;
    required uint32 latest_msg_from_user_id = 7;        //发送得用户id
}
```



### 8.获取消息

![image-20230520191028718](assets/image-20230520191028718.png)

CID_MSG_LIST_REQUEST

- CMsgConn::_HandleClientGetMsgListRequest（msg_server模块）响应客户端的 CID_MSG_LIST_REQUEST，并使⽤CID_MSG_LIST_REQUEST转发给db_proxy_server
- DB_PROXY::getMessage(db_proxy_server模块)：
  - 单聊消息使⽤CMessageModel::getMessage读取消息，查询IMMessage_x表
  - 群聊消息使⽤CMessageModel::getMessage读取消息，查询IMGroupMessage_x表

- 使⽤CID_MSG_LIST_RESPONSE发回给msg_server
- CDBServConn::_HandleGetMsgListResponse（msg_server模块），发回给客户端。


CDBServConn::_HandleValidateResponse 检测到新登录成功时则踢掉⽼登录。使⽤CID_OTHER_SERVER_KICK_USER命令，通过⼴播的⽅式进⾏

### 9.新登录用户踢掉老用户

- CRouteConn::HandlePdu （route_server模块）响应CID_OTHER_SERVER_KICK_USER后原封不动转发到各个msg_server
- CRouteServConn::_HandleKickUser（msg_server模块）响应CID_OTHER_SERVER_KICK_USER，如果改user在当前msg_server，则CImUser::KickOutSameClientType查找是否有重复的登录，并通过对应的CImConn发送回给客户端。



![image-20230521084643680](assets/image-20230521084643680.png)



