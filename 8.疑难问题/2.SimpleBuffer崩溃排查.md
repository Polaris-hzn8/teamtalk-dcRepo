# 崩溃排查

---

### msg_server无法启动

msg_server无法启动，运行后直接生成崩溃转存储文件：core.3356，

#### sudo gdb ./msg_server core.1043

利用gdb分析现有的转存储文件：

```shell
sudo gdb ./msg_server core.1043
```

```shell
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./msg_server...done.

warning: exec file is newer than core file.
[New LWP 1043]
[New LWP 1057]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/home/ubuntu/teamtalk-server/im_server_pack/msg_server/msg_server'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055cbe96eb029 in CByteStream::WriteInt32 (buf=0x0, data=0) at /home/ubuntu/teamtalk-server/src/base/impdu/UtilPdu.cpp:165
165	    buf[0] = static_cast<uchar_t>(data >> 24);
[Current thread is 1 (Thread 0x7f9634c75780 (LWP 1043))]
```

崩溃信息如下：

- 信号：`SIGSEGV` → 内存访问违规（Segmentation Fault）
- 崩溃函数：`CByteStream::WriteInt32`
- 崩溃原因：`buf` 是 `0x0`（空指针），却尝试访问 `buf[0]`，典型的空指针访问。

#### bt查看调用堆栈

利用bt命令查看函数调用堆栈，追踪具体是哪个函数传入了 `nullptr` 给 `WriteInt32`，从而导致的程序崩溃。

```
(gdb) bt
#0  0x000055cbe96eb029 in CByteStream::WriteInt32 (buf=0x0, data=0) at /home/ubuntu/teamtalk-server/src/base/impdu/UtilPdu.cpp:165
#1  0x000055cbe96ea748 in CImPdu::WriteHeader (this=0x7ffecc9156e0) at /home/ubuntu/teamtalk-server/src/base/impdu/ImPduBase.cpp:129
#2  0x000055cbe96eaa6a in CImPdu::SetPBMsg (this=0x7ffecc9156e0, msg=0x7ffecc915710) at /home/ubuntu/teamtalk-server/src/base/impdu/ImPduBase.cpp:171
#3  0x000055cbe962782e in CFileServConn::OnConfirm (this=0x55cbeb7ed720) at /home/ubuntu/teamtalk-server/src/msg_server/FileServConn.cpp:139
#4  0x000055cbe96ec3c1 in imconn_callback (callback_data=0x55cbe99571c0 <g_file_server_conn_map>, msg=2 '\002', handle=7, pParam=0x0) at /home/ubuntu/teamtalk-server/src/base/impdu/imconn.cpp:171
#5  0x000055cbe96f1c52 in CBaseSocket::OnWrite (this=0x55cbeb7ee650) at /home/ubuntu/teamtalk-server/src/base/netlib/BaseSocket.cpp:276
#6  0x000055cbe96f4a57 in CEventDispatch::StartDispatch (this=0x55cbe995dac0 <CEventDispatch::Instance()::eventDispatch>, wait_timeout=100) at /home/ubuntu/teamtalk-server/src/base/netlib/EventDispatch.cpp:349
#7  0x000055cbe96f03c3 in netlib_eventloop (wait_timeout=100) at /home/ubuntu/teamtalk-server/src/base/netlib/netlib.cpp:157
#8  0x000055cbe9653237 in main (argc=1, argv=0x7ffecc918ab8) at /home/ubuntu/teamtalk-server/src/msg_server/msg_server.cpp:145
(gdb) print buf
$1 = (uchar_t *) 0x0
(gdb) print data
$2 = 0
(gdb) 
```

调用链分析：

1. CImPdu::WriteHeader
2. CImPdu::SetPBMsg
3. CFileServConn::OnConfirm
4. imconn_callback
5. CBaseSocket::OnWrite
6. CEventDispatch::StartDispatch
7. netlib_eventloop
8. main

#### 具体调用情况

##### CFileServConn::OnConfirm

```cpp
void CFileServConn::OnConfirm()
{
    log("connect to file server success ");
    m_bOpen = true;
    m_connect_time = get_tick_count();
    g_file_server_list[m_serv_idx].reconnect_cnt = MIN_RECONNECT_CNT / 2;

    IM::Server::IMFileServerIPReq msg;
    CImPdu pdu;
    pdu.SetPBMsg(&msg);
    pdu.SetServiceId(SID_OTHER);
    pdu.SetCommandId(CID_OTHER_FILE_SERVER_IP_REQ);
    SendPdu(&pdu);
}
```

##### CImPdu::SetPBMsg

```cpp
bool CImPdu::SetPBMsg(const google::protobuf::MessageLite* msg)
{
    // 读空缓冲区
    m_buf.Read(NULL, m_buf.GetWriteOffset());
    // 扩容缓冲区
    m_buf.Write(NULL, sizeof(PduHeader_t));

    uint32_t msg_size = msg->ByteSize();
    uchar_t* szData = new uchar_t[msg_size];
    if (!msg->SerializeToArray(szData, msg_size))
        log_error("pb msg miss required fields.");

    m_buf.Write(szData, msg_size);
    delete[] szData;

    WriteHeader();
    return true;
}
```

定位为：CSimpleBuffer类中的修改，在服务器之间进行消息传递时使用CSimpleBuffer，导致的程序崩溃，

##### 头文件

```cpp
class DLL_MODIFIER CSimpleBuffer
{
public:
	CSimpleBuffer();
	~CSimpleBuffer();
	
	uchar_t*  	GetBuffer() { return m_buffer; }
	uint32_t 	GetAllocSize() { return m_alloc_size; }
	uint32_t 	GetWriteOffset() { return m_write_offset; }
	void 		IncWriteOffset(uint32_t len) { m_write_offset += len; }

	bool 		Extend(uint32_t len);
	uint32_t 	Write(void* buf, uint32_t len);
	uint32_t 	Read(void* buf, uint32_t len);
private:
	uchar_t*	m_buffer;			//缓冲区指针
	uint32_t	m_alloc_size;		//缓冲区大小
	uint32_t	m_write_offset;		//写入偏移量 
};
```

##### 出问题的代码

```cpp
///////////// CSimpleBuffer ////////////////
CSimpleBuffer::CSimpleBuffer()
{
    m_buffer = NULL;
    m_alloc_size = 0;
    m_write_offset = 0;
}

CSimpleBuffer::~CSimpleBuffer()
{
    m_alloc_size = 0;
    m_write_offset = 0;
    if (m_buffer) {
        free(m_buffer);
        m_buffer = NULL;
    }
}

bool CSimpleBuffer::Extend(uint32_t len)
{
    if (m_write_offset + len < m_write_offset)
        return false;//溢出

    // new_size
    uint32_t new_size = m_write_offset + len;
    new_size += new_size >> 2;

    // new_buf
    uchar_t* new_buf = (uchar_t*)realloc(m_buffer, new_size);
    if (!new_buf)
        return false;
        
    m_buffer = new_buf;
    m_alloc_size = new_size;
    return true;
}

uint32_t CSimpleBuffer::Write(void* buf, uint32_t len)
{
    if (!buf || len <= 0)
        return 0;
    
    if (len > UINT32_MAX - m_write_offset)
        return 0;

    if (m_write_offset + len > m_alloc_size)
        if (!Extend(len))
            return 0;

    // data write
    memcpy(m_buffer + m_write_offset, buf, len);
    m_write_offset += len;
    return len;
}

uint32_t CSimpleBuffer::Read(void* buf, uint32_t len)
{
    if (!buf || !m_buffer || len == 0 || m_write_offset == 0)
        return 0;

    // data read
    len = std::min(len, m_write_offset);
    memcpy(buf, m_buffer, len);

    m_write_offset -= len;
    if (m_write_offset)
        memmove(m_buffer, m_buffer + len, m_write_offset);//向前移动len字节(有剩余数据)

    return len;
}
```

##### 原来没有问题的代码

```cpp
///////////// CSimpleBuffer ////////////////
CSimpleBuffer::CSimpleBuffer()
{
	m_buffer = NULL;

	m_alloc_size = 0;
	m_write_offset = 0;
}

CSimpleBuffer::~CSimpleBuffer()
{
	m_alloc_size = 0;
	m_write_offset = 0;
	if (m_buffer)
	{
		free(m_buffer);
		m_buffer = NULL;
	}
}

void CSimpleBuffer::Extend(uint32_t len)
{
	m_alloc_size = m_write_offset + len;
	m_alloc_size += m_alloc_size >> 2;	// increase by 1/4 allocate size
	uchar_t* new_buf = (uchar_t*)realloc(m_buffer, m_alloc_size);
	m_buffer = new_buf;
}

uint32_t CSimpleBuffer::Write(void* buf, uint32_t len)
{
	if (m_write_offset + len > m_alloc_size)
	{
		Extend(len);
	}

	if (buf)
	{
		memcpy(m_buffer + m_write_offset, buf, len);
	}

	m_write_offset += len;

	return len;
}

uint32_t CSimpleBuffer::Read(void* buf, uint32_t len)
{
    if (0 == len) 
        return len;
	if (len > m_write_offset)
		len = m_write_offset;

	if (buf)
		memcpy(buf, m_buffer, len);

	m_write_offset -= len;
	memmove(m_buffer, m_buffer + len, m_write_offset);
	return len;
}
```

##### 分析结果

关键代码：

```cpp
// 重置缓冲区偏移
m_buf.Read(NULL, m_buf.GetWriteOffset());
// 扩展缓冲区写入区域，但暂不填充数据 预留出PDUheader空间
m_buf.Write(NULL, sizeof(PduHeader_t));
```

| 关键点                  | 没有问题的版本            | 出现问题的版本         |
| ----------------------- | ------------------------- | ---------------------- |
| `Write(NULL, len)` 行为 | 扩容 buffer 并更新 offset | 直接返回 0，不扩容     |
| `m_buffer`              | 被正确分配                | 永远保持 NULL          |
| 结果                    | WriteHeader 正常执行      | WriteHeader 空指针崩溃 |









