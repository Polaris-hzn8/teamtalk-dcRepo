# ui代理窗口事件处理

---

客户端涉及线程：

1. 网络IO线程负责处理IO数据的读写操作
2. 主线程用于界面消息循环与用户交互，并且与IO线程进行数据交换

### UI代理窗口事件处理

基于win32消息机制实现的，观察者+异步事件系统，可以解决跨线程UI安全调用的问题。

基于操作 + 事件驱动的异步框架，将耗时操作与UI线程解耦合，靠 `ICallbackOperation → CallbackOperationEvent → IEvent` 这条链路通知 UI。

设计优点：

1. 典型观察者模式：多模块之间解耦，通过 keyId + 回调传参
2. UI 线程安全：所有通知通过 `UIEventManager` → `PostMessage` → 确保回调执行在 UI 线程。

详细设计：

1. ModuleBase / ModuleSubject / ModuleObserverCtx (观察者模式)：
   - `ModuleBase` → 业务模块的基类，统一持有 `ModuleSubject`。
   - `ModuleSubject` → 管理观察者列表（`std::vector<ModuleObserverCtx*>`），提供 `addObserver/removeObserver` 和 `asynNotifyObserver`。
   - `ModuleObserverCtx` → 保存了观察者对象指针 + 回调 `MKODelegate`。
   - 通过 `MKOEvent_Impl` 封装事件，丢给 `UIEventManager` 异步执行。
2. UIEventManager (基于 Win32 消息循环的异步调度器)
   - 内部开了一个 **消息专用窗口（`HWND_MESSAGE`）**。
   - 通过 `PostMessage` 把 `IEvent*` 事件对象投递到该窗口中
   - `_WindowProc` 里分发事件：
     - 普通事件：调用 `pEvent->process()`。
     - 定时器事件：`_processTimer` 遍历 `m_lstTimers` 调度。
3. IEvent / ITimerEvent / ICallbackOpertaion (事件接口层)
   - `IEvent` → 所有事件基类，必须实现 `process/release`
   - `ITimerEvent` → 定时器事件接口。
   - `MKOEvent_Impl` → 观察者事件，持有参数，调用注册的回调。
   - `CallbackOperationEvent` → 带回调的异步操作事件。
   - `ICallbackOpertaion` → 提供 `syncCallback` / `asyncCallback` 两种模式。

后台模块与界面之间也会进行通信，但该数据流通的方式比asyncCallback异步通知更复杂些，具体如下：

![image-20230604112834252](assets/image-20230604112834252.png)

之前的CallbackOperationEvent和IMKOEvent都是继承于IEvent，并进行重写process方法，而各个后台模块都是ModuleBase的基类，每个模块都拥有ModuleSubject的指针，可以进行添加观察者，这里使用的是观察者模式，如后台数据的变化会导致多个界面或者多个地方会发生改变，

1. 此时ModuleBase类通过添加需要改变的类，然后进行通知，
2. 将MKOEvent_Impl事件给ui代理线程，ui线程将调用MKOEvent_Impl的process，
3. 在process中调用ModuleSubject中的每个ModuleObjectCtx中的回调函数，这样就完成了后台数据发生变化可以通知到多个地方的操作，







