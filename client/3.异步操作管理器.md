# 异步操作管理器

---

### OperationManager.h

```cpp
#ifndef OPERATIONMANAGER_7EEF3272_2557_4A76_9C25_67D4639F40DB_H__
#define OPERATIONMANAGER_7EEF3272_2557_4A76_9C25_67D4639F40DB_H__

#include <list>
#include <mutex>
#include <thread>
#include <atomic>
#include <string>
#include <functional>
#include <condition_variable>
#include "network/ErrorCode.h"

NAMESPACE_BEGIN(imcore)

/**
 * @brief OperationManager 异步任务管理器
 * 支持延迟执行和实时执行的任务调度
 * 内部维护独立工作线程，通过条件变量唤醒
 * 特点：
 *  - 单例访问（getOperationManager）
 *  - 线程安全
 *  - 支持延迟任务和 lambda 任务
 */
class Operation;
class OperationManager
{
public:
	OperationManager() = default;
	~OperationManager();
	// 禁止拷贝与移动
	OperationManager(OperationManager&) = delete;
	OperationManager(OperationManager&&) = delete;
	OperationManager& operator= (OperationManager&) = delete;
	OperationManager& operator= (OperationManager&&) = delete;

public:
	IMCoreErrorCode startup();
    void shutdown(IN int seconds = 2000);
    IMCoreErrorCode startOperation(IN Operation* pOperation, Int32 delay);
    IMCoreErrorCode startOperationWithLambda(std::function<void()> operationRun, Int32 delay, std::string oper_name);
    IMCoreErrorCode clearOperationByName(std::string oper_name);

private:
	std::list<Operation*>      m_vecDelayOperations;
	std::list<Operation*>      m_vecRealtimeOperations;

	std::mutex					m_cvMutex;	// 互斥锁
	std::condition_variable		m_cv;		// 条件变量

	std::mutex					m_mutexOperation;
	std::atomic_bool			m_bContinue{ true };	// 运行标志（线程安全）
	std::thread					m_operationThread;
};

OperationManager* getOperationManager();

NAMESPACE_END(imcore)

#endif// OPERATIONMANAGER_7EEF3272_2557_4A76_9C25_67D4639F40DB_H__
```



### OperationManager.cpp

```cpp
#include <algorithm>
#include "GlobalConfig.h"
#include "yaolog/yaolog.h"
#include "OperationManager.h"
#include "network/Operation.h"

namespace
{
	class LambdaOperation : public Operation
	{
	public:
		LambdaOperation(std::function<void()> operationRun)
			:m_operationRun(operationRun)
		{
		}
		virtual void processOpertion()
		{
			m_operationRun();
		}
		virtual void release()
		{
			delete this;
		}
	private:
		std::function<void()> m_operationRun;
	};
}

OperationManager::~OperationManager()
{
	try
	{
		shutdown();
	}
	catch (...)
	{
		LOG__(ERR, _T("OperationManager: shutdown throw unknown exception"));
		assert(FALSE);
	}
}

// 启动线程
IMCoreErrorCode OperationManager::startup()
{
	if (m_operationThread.joinable())
		return IMCORE_OK;

	m_bContinue.store(true);
	m_operationThread = std::thread([this]
	{
		std::unique_lock <std::mutex> lck(m_cvMutex);
		while (m_bContinue.load())
		{
			//if (m_vecRealtimeOperations.empty())
			//	m_cv.wait(lck);
			m_cv.wait(lck, [this]() {
				return !m_bContinue.load() || !m_vecRealtimeOperations.empty();
			});

			if (!m_bContinue.load())
				break;

			Operation* pOperation = nullptr;
			{
				std::lock_guard<std::mutex> lock(m_mutexOperation);
				if (!m_vecRealtimeOperations.empty())
				{
					pOperation = m_vecRealtimeOperations.front();
					m_vecRealtimeOperations.pop_front();
				}
			}
			if (pOperation)
			{
				try
				{
					pOperation->process();
				}
				catch (...)
				{
					LOG__(ERR, _T("OperationManager: operation threw exception"));
				}
				pOperation->release();
			}
		}
	});

	return IMCORE_OK;
}

// 安全停止
void OperationManager::shutdown(IN int seconds /*= 2000*/)
{
	m_bContinue.store(false);
	m_cv.notify_all();

	//bug: join may be infinite waiting
	//if (m_operationThread.joinable())
	//	m_operationThread.join();

	auto start = std::chrono::steady_clock::now();
	while (m_operationThread.joinable())
	{
		auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start);
		if (elapsed.count() > seconds * 1000)
		{
			LOG__(ERR, _T("OperationManager::shutdown timeout waiting for thread join"));
			break;
		}
		try
		{
			m_operationThread.join();
		}
		catch (...)
		{
			LOG__(ERR, _T("OperationManager::shutdown join failed"));
			break;
		}
	}

	std::lock_guard<std::mutex> locker(m_mutexOperation);
	// m_vecRealtimeOperations
	for (auto* pOperation : m_vecRealtimeOperations)
	{
		try
		{
			pOperation->release();
		}
		catch (...)
		{
			LOG__(ERR, _T("OperationManager: operation release threw exception"));
		}
	}
	m_vecRealtimeOperations.clear();

	// m_vecDelayOperations
	for (auto* pOperation : m_vecDelayOperations)
	{
		delete pOperation;
		pOperation = nullptr;
	}
	m_vecDelayOperations.clear();
}

IMCoreErrorCode OperationManager::startOperation(IN Operation* pOperation, Int32 delay)
{
	if (!pOperation)
	{
		LOG__(ERR, _T("startOperation pOperation nullptr"));
		return IMCORE_ARGUMENT_ERROR;
	}

	if (delay > 0)
	{
		std::thread([this, pOperation, delay]()
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(delay));
			{
				std::lock_guard<std::mutex> locker(m_mutexOperation);
				m_vecRealtimeOperations.push_back(pOperation);
			}
			m_cv.notify_one();
		}).detach();
	}
	else
	{
		std::lock_guard<std::mutex> locker(m_mutexOperation);
		m_vecRealtimeOperations.push_back(pOperation);
		m_cv.notify_one();
	}

	return IMCORE_OK;
}

IMCoreErrorCode OperationManager::startOperationWithLambda(
	std::function<void()> operationRun,
	Int32 delay,
	std::string oper_name)
{
    LambdaOperation* pLambdaOper = new LambdaOperation(operationRun);
    pLambdaOper->set_name(oper_name);
    return startOperation(pLambdaOper, delay);
}

IMCoreErrorCode OperationManager::clearOperationByName(std::string oper_name)
{
    std::lock_guard<std::mutex> locker(m_mutexOperation);
    auto iter = std::remove_if(
		m_vecRealtimeOperations.begin(),
		m_vecRealtimeOperations.end(),
        [&](Operation* pOper)
    {
        if (pOper->name() == oper_name)
        {
            LOG__(APP, _T("clearOperationByName - %S"), oper_name.c_str());
            pOper->release();
            return true;
        }
        return false;
    });

    if (iter != m_vecRealtimeOperations.end())
    {
        m_vecRealtimeOperations.erase(iter, m_vecRealtimeOperations.end());
    }

    return IMCORE_OK;
}

OperationManager* getOperationManager()
{
	static OperationManager manager;
	return &manager;
}
```













